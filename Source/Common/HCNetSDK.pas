unit HCNETSDK;
{**************************************************************************}
{                                                                          }
{    This C DLL header file first (automatic) conversion generated by:     }
{    HeadConv 4.0 (c) 2000 by Bob Swart (aka Dr.Bob - www.drbob42.com)     }
{      Final Delphi-Jedi (Darth) command-line units edition                }
{                                                                          }
{    Generated Date:  2009-5-20                                            }
{    Generated Time: 17:37:27                                              }
{                                                                          }
{**************************************************************************}

interface
uses
{$IFDEF WIN32}
  Windows;
{$ELSE}
  Wintypes, WinProcs;
{$ENDIF}


{=> f:\tddownload\headconv\HCNETSDK.H <=}

{$IFNDEF _HC_NET_SDK_H_}
{$DEFINE _HC_NET_SDK_H_}


{///宏定义 }
const
  MAX_NAMELEN = 16; {//DVR本地登陆名}
const
  MAX_RIGHT = 32; {//设备支持的权限（1-21表示本地权限，13-32表示远程权限）}
const
  NAME_LEN = 32; {//用户名长度}
const
  PASSWD_LEN = 16; {//密码长度}
const
  SERIALNO_LEN = 48; {//序列号长度}
const
  MACADDR_LEN = 6; {//mac地址长度}
const
  MAX_ETHERNET = 2; {//设备可配以太网络}
const
  PATHNAME_LEN = 128; {//路径长度}
const
 MAX_CHJC_NUM = 3;    //最大车辆省份简称字符个数
const MAX_LANERECT_NUM = 5 ;   //最大车道识别区域数
const
MAX_INTERVAL_NUM = 4;
const
  MAX_TIMESEGMENT_V30 = 8; {//9000设备最大时间段数}
const
  MAX_TIMESEGMENT = 4; {//8000设备最大时间段数}

const
  MAX_SHELTERNUM = 4; {//8000设备最大遮挡区域数}
const
  MAX_DAYS = 7; {//每周天数}
const
  PHONENUMBER_LEN = 32; {//pppoe拨号号码最大长度}

const
  MAX_DISKNUM_V30 = 33; {//9000设备最大硬盘数/* 最多33个硬盘(包括16个内置SATA硬盘、1个eSATA硬盘和16个NFS盘)*/}
const
  MAX_DISKNUM = 16; {//8000设备最大硬盘数}
const
  MAX_DISKNUM_V10 = 8; {//1.2版本之前版本}

const
  MAX_WINDOW_V30 = 32; {//9000设备本地显示最大播放窗口数}
const
  MAX_WINDOW = 16; {//8000设备最大硬盘数}
const
  MAX_VGA_V30 = 4; {//9000设备最大可接VGA数}
const
  MAX_VGA = 1; {//8000设备最大可接VGA数}

const
  MAX_USERNUM_V30 = 32; {//9000设备最大用户数}
const
  MAX_USERNUM = 16; {//8000设备最大用户数}
const
  MAX_EXCEPTIONNUM_V30 = 32; {//9000设备最大异常处理数}
const
  MAX_EXCEPTIONNUM = 16; {//8000设备最大异常处理数}
const
  MAX_LINK = 6; {//8000设备单通道最大视频流连接数}

const
  MAX_DECPOOLNUM = 4; {//单路解码器每个解码通道最大可循环解码数}
const
  MAX_DECNUM = 4; {//单路解码器的最大解码通道数（实际只有一个，其他三个保留）}
const
  MAX_TRANSPARENTNUM = 2; {//单路解码器可配置最大透明通道数}
const
  MAX_CYCLE_CHAN = 16; {//单路解码器最大轮循通道数}
const
  MAX_DIRNAME_LENGTH = 80; {//最大目录长度}

const
  MAX_STRINGNUM_V30 = 8; {//9000设备最大OSD字符行数数}
const
  MAX_STRINGNUM = 4; {//8000设备最大OSD字符行数数}
const
  MAX_STRINGNUM_EX = 8; {//8000定制扩展}
const
  MAX_AUXOUT_V30 = 16; {//9000设备最大辅助输出数}
const
  MAX_AUXOUT = 4; {//8000设备最大辅助输出数}
const
  MAX_HD_GROUP = 16; {//9000设备最大硬盘组数}
const
  MAX_NFS_DISK = 8; {//8000设备最大NFS硬盘数}

const
  IW_ESSID_MAX_SIZE = 32; {//WIFI的SSID号长度}
const
  IW_ENCODING_TOKEN_MAX = 32; {//WIFI密锁最大字节数}
const
  MAX_SERIAL_NUM = 64; {//最多支持的透明通道路数}
const
  MAX_DDNS_NUMS = 10; {//9000设备最大可配ddns数}
const
  MAX_DOMAIN_NAME = 64; {/* 最大域名长度*/}

const
  MAXPROGRESS = 100; {//回放时的最大百分率}
const
  MAX_SERIALNUM = 2; {//8000设备支持的串口数 1-232， 2-485}
const
  CARDNUM_LEN = 20; {//卡号长度}
const
  MAX_VIDEOOUT_V30 = 4; {//9000设备的视频输出数}
const
  MAX_VIDEOOUT = 2; {//8000设备的视频输出数}

const
  MAX_PRESET_V30 = 256; {/* 9000设备支持的云台预置点数*/}
const
  MAX_TRACK_V30 = 256; {/* 9000设备支持的云台轨迹数*/}
const
  MAX_CRUISE_V30 = 256; {/* 9000设备支持的云台巡航数*/}
const
  MAX_PRESET = 128; {/* 8000设备支持的云台预置点数*/}
const
  MAX_TRACK = 128; {/* 8000设备支持的云台轨迹数*/}
const
  MAX_CRUISE = 128; {/* 8000设备支持的云台巡航数*/}

const
  CRUISE_MAX_PRESET_NUMS = 32; {/* 一条巡航最多的巡航点*/}

const
  MAX_SERIAL_PORT = 8; {//9000设备支持232串口数}
const
  MAX_PREVIEW_MODE = 8; {/* 设备支持最大预览模式数目 1画面,4画面,9画面,16画面....*/}
const
  MAX_MATRIXOUT = 16; {/* 最大模拟矩阵输出个数*/}
const
  LOG_INFO_LEN = 11840; {/* 日志附加信息*/}
const
  DESC_LEN = 16; {/* 云台描述字符串长度*/}
const
  PTZ_PROTOCOL_NUM = 200; {/* 9000最大支持的云台协议数*/}

const
  MAX_AUDIO = 1; {//8000语音对讲通道数}
const
  MAX_AUDIO_V30 = 2; {//9000语音对讲通道数}
const
  MAX_CHANNUM = 16; {//8000设备最大通道数}
const
  MAX_ALARMIN = 16; {//8000设备最大报警输入数}
const
  MAX_ALARMOUT = 4; {//8000设备最大报警输出数}
{///9000 IPC接入 }
const
  MAX_ANALOG_CHANNUM = 32; {//最大32个模拟通道}
const
  MAX_ANALOG_ALARMOUT = 32; {//最大32路模拟报警输出}
const
  MAX_ANALOG_ALARMIN = 32; {//最大32路模拟报警输入}

const
  MAX_IP_DEVICE = 32; {//允许接入的最大IP设备数}
const
  MAX_IP_CHANNEL = 32; {//允许加入的最多IP通道数}
const
  MAX_IP_ALARMIN = 128; {//允许加入的最多报警输入数}
const
  MAX_IP_ALARMOUT = 64; {//允许加入的最多报警输出数}

{+// 最大支持的通道数 最大模拟加上最大IP支持*/ }
const
  MAX_CHANNUM_V30 = ( MAX_ANALOG_CHANNUM + MAX_IP_CHANNEL);{//64}
const
  MAX_ALARMOUT_V30 = ( MAX_ANALOG_ALARMOUT + MAX_IP_ALARMOUT);{//96}
const
  MAX_ALARMIN_V30 = ( MAX_ANALOG_ALARMIN + MAX_IP_ALARMIN);{//160}

const
  MAX_ITC_LANE_NUM = 6;
const
  MAX_IOOUT_NUM = 4;
const
  MAX_LANEAREA_NUM = 2;
const
  MAX_OVERLAP_ITEM_NUM = 50;
{+//******************全局错误码 begin**********************/ }
const
  NET_DVR_FAIL = -1;
const
  NET_DVR_NOERROR = 0; {//没有错误}
const
  NET_DVR_PASSWORD_ERROR = 1; {//用户名密码错误}
const
  NET_DVR_NOENOUGHPRI = 2; {//权限不足}
const
  NET_DVR_NOINIT = 3; {//没有初始化}
const
  NET_DVR_CHANNEL_ERROR = 4; {//通道号错误}
const
  NET_DVR_OVER_MAXLINK = 5; {//连接到DVR的客户端个数超过最大}
const
  NET_DVR_VERSIONNOMATCH = 6; {//版本不匹配}
const
  NET_DVR_NETWORK_FAIL_CONNECT = 7; {//连接服务器失败}
const
  NET_DVR_NETWORK_SEND_ERROR = 8; {//向服务器发送失败}
const
  NET_DVR_NETWORK_RECV_ERROR = 9; {//从服务器接收数据失败}
const
  NET_DVR_NETWORK_RECV_TIMEOUT = 10; {//从服务器接收数据超时}
const
  NET_DVR_NETWORK_ERRORDATA = 11; {//传送的数据有误}
const
  NET_DVR_ORDER_ERROR = 12; {//调用次序错误}
const
  NET_DVR_OPERNOPERMIT = 13; {//无此权限}
const
  NET_DVR_COMMANDTIMEOUT = 14; {//DVR命令执行超时}
const
  NET_DVR_ERRORSERIALPORT = 15; {//串口号错误}
const
  NET_DVR_ERRORALARMPORT = 16; {//报警端口错误}
const
  NET_DVR_PARAMETER_ERROR = 17; {//参数错误}
const
  NET_DVR_CHAN_EXCEPTION = 18; {//服务器通道处于错误状态}
const
  NET_DVR_NODISK = 19; {//没有硬盘}
const
  NET_DVR_ERRORDISKNUM = 20; {//硬盘号错误}
const
  NET_DVR_DISK_FULL = 21; {//服务器硬盘满}
const
  NET_DVR_DISK_ERROR = 22; {//服务器硬盘出错}
const
  NET_DVR_NOSUPPORT = 23; {//服务器不支持}
const
  NET_DVR_BUSY = 24; {//服务器忙}
const
  NET_DVR_MODIFY_FAIL = 25; {//服务器修改不成功}
const
  NET_DVR_PASSWORD_FORMAT_ERROR = 26; {//密码输入格式不正确}
const
  NET_DVR_DISK_FORMATING = 27; {//硬盘正在格式化，不能启动操作}
const
  NET_DVR_DVRNORESOURCE = 28; {//DVR资源不足}
const
  NET_DVR_DVROPRATEFAILED = 29; {//DVR操作失败}
const
  NET_DVR_OPENHOSTSOUND_FAIL = 30; {//打开PC声音失败}
const
  NET_DVR_DVRVOICEOPENED = 31; {//服务器语音对讲被占用}
const
  NET_DVR_TIMEINPUTERROR = 32; {//时间输入不正确}
const
  NET_DVR_NOSPECFILE = 33; {//回放时服务器没有指定的文件}
const
  NET_DVR_CREATEFILE_ERROR = 34; {//创建文件出错}
const
  NET_DVR_FILEOPENFAIL = 35; {//打开文件出错}
const
  NET_DVR_OPERNOTFINISH = 36; {//上次的操作还没有完成}
const
  NET_DVR_GETPLAYTIMEFAIL = 37; {//获取当前播放的时间出错}
const
  NET_DVR_PLAYFAIL = 38; {//播放出错}
const
  NET_DVR_FILEFORMAT_ERROR = 39; {//文件格式不正确}
const
  NET_DVR_DIR_ERROR = 40; {//路径错误}
const
  NET_DVR_ALLOC_RESOURCE_ERROR = 41; {//资源分配错误}
const
  NET_DVR_AUDIO_MODE_ERROR = 42; {//声卡模式错误}
const
  NET_DVR_NOENOUGH_BUF = 43; {//缓冲区太小}
const
  NET_DVR_CREATESOCKET_ERROR = 44; {//创建SOCKET出错}
const
  NET_DVR_SETSOCKET_ERROR = 45; {//设置SOCKET出错}
const
  NET_DVR_MAX_NUM = 46; {//个数达到最大}
const
  NET_DVR_USERNOTEXIST = 47; {//用户不存在}
const
  NET_DVR_WRITEFLASHERROR = 48; {//写FLASH出错}
const
  NET_DVR_UPGRADEFAIL = 49; {//DVR升级失败}
const
  NET_DVR_CARDHAVEINIT = 50; {//解码卡已经初始化过}
const
  NET_DVR_PLAYERFAILED = 51; {//调用播放库中某个函数失败}
const
  NET_DVR_MAX_USERNUM = 52; {//设备端用户数达到最大}
const
  NET_DVR_GETLOCALIPANDMACFAIL = 53; {//获得客户端的IP地址或物理地址失败}
const
  NET_DVR_NOENCODEING = 54; {//该通道没有编码}
const
  NET_DVR_IPMISMATCH = 55; {//IP地址不匹配}
const
  NET_DVR_MACMISMATCH = 56; {//MAC地址不匹配}
const
  NET_DVR_UPGRADELANGMISMATCH = 57; {//升级文件语言不匹配}
const
  NET_DVR_MAX_PLAYERPORT = 58; {//播放器路数达到最大}
const
  NET_DVR_NOSPACEBACKUP = 59; {//备份设备中没有足够空间进行备份}
const
  NET_DVR_NODEVICEBACKUP = 60; {//没有找到指定的备份设备}
const
  NET_DVR_PICTURE_BITS_ERROR = 61; {//图像素位数不符，限24色}
const
  NET_DVR_PICTURE_DIMENSION_ERROR = 62; {//图片高*宽超限， 限128*256}
const
  NET_DVR_PICTURE_SIZ_ERROR = 63; {//图片大小超限，限100K}
const
  NET_DVR_LOADPLAYERSDKFAILED = 64; {//载入当前目录下Player Sdk出错}
const
  NET_DVR_LOADPLAYERSDKPROC_ERROR = 65; {//找不到Player Sdk中某个函数入口}
const
  NET_DVR_LOADDSSDKFAILED = 66; {//载入当前目录下DSsdk出错}
const
  NET_DVR_LOADDSSDKPROC_ERROR = 67; {//找不到DsSdk中某个函数入口}
const
  NET_DVR_DSSDK_ERROR = 68; {//调用硬解码库DsSdk中某个函数失败}
const
  NET_DVR_VOICEMONOPOLIZE = 69; {//声卡被独占}
const
  NET_DVR_JOINMULTICASTFAILED = 70; {//加入多播组失败}
const
  NET_DVR_CREATEDIR_ERROR = 71; {//建立日志文件目录失败}
const
  NET_DVR_BINDSOCKET_ERROR = 72; {//绑定套接字失败}
const
  NET_DVR_SOCKETCLOSE_ERROR = 73; {//socket连接中断，此错误通常是由于连接中断或目的地不可达}
const
  NET_DVR_USERID_ISUSING = 74; {//注销时用户ID正在进行某操作}
const
  NET_DVR_SOCKETLISTEN_ERROR = 75; {//监听失败}
const
  NET_DVR_PROGRAM_EXCEPTION = 76; {//程序异常}
const
  NET_DVR_WRITEFILE_FAILED = 77; {//写文件失败}
const
  NET_DVR_FORMAT_READONLY = 78; {//禁止格式化只读硬盘}
const
  NET_DVR_WITHSAMEUSERNAME = 79; {//用户配置结构中存在相同的用户名}
const
  NET_DVR_DEVICETYPE_ERROR = 80; {/*导入参数时设备型号不匹配*/}
const
  NET_DVR_LANGUAGE_ERROR = 81; {/*导入参数时语言不匹配*/}
const
  NET_DVR_PARAVERSION_ERROR = 82; {/*导入参数时软件版本不匹配*/}
const
  NET_DVR_IPCHAN_NOTALIVE = 83; {/*预览时外接IP通道不在线*/}
const
  NET_DVR_RTSP_SDK_ERROR = 84; {/*加载高清IPC通讯库StreamTransClient失败*/}
const
  NET_DVR_CONVERT_SDK_ERROR = 85; {/*加载转码库CVT_StdToHik失败*/}
const
  NET_DVR_IPC_COUNT_OVERFLOW = 86; {/*超出最大的ip接入通道数*/}

const
  NET_PLAYM4_NOERROR = 500; {//no error}
const
  NET_PLAYM4_PARA_OVER = 501; {//input parameter is invalid;}
const
  NET_PLAYM4_ORDER_ERROR = 502; {//The order of the function to be called is error.}
const
  NET_PLAYM4_TIMER_ERROR = 503; {//Create multimedia clock failed;}
const
  NET_PLAYM4_DEC_VIDEO_ERROR = 504; {//Decode video data failed.}
const
  NET_PLAYM4_DEC_AUDIO_ERROR = 505; {//Decode audio data failed.}
const
  NET_PLAYM4_ALLOC_MEMORY_ERROR = 506; {//Allocate memory failed.}
const
  NET_PLAYM4_OPEN_FILE_ERROR = 507; {//Open the file failed.}
const
  NET_PLAYM4_CREATE_OBJ_ERROR = 508; {//Create thread or event failed}
const
  NET_PLAYM4_CREATE_DDRAW_ERROR = 509; {//Create DirectDraw object failed.}
const
  NET_PLAYM4_CREATE_OFFSCREEN_ERROR = 510; {//failed when creating off-screen surface.}
const
  NET_PLAYM4_BUF_OVER = 511; {//buffer is overflow}
const
  NET_PLAYM4_CREATE_SOUND_ERROR = 512; {//failed when creating audio device.}
const
  NET_PLAYM4_SET_VOLUME_ERROR = 513; {//Set volume failed}
const
  NET_PLAYM4_SUPPORT_FILE_ONLY = 514; {//The function only support play file.}
const
  NET_PLAYM4_SUPPORT_STREAM_ONLY = 515; {//The function only support play stream.}
const
  NET_PLAYM4_SYS_NOT_SUPPORT = 516; {//System not support.}
const
  NET_PLAYM4_FILEHEADER_UNKNOWN = 517; {//No file header.}
const
  NET_PLAYM4_VERSION_INCORRECT = 518; {//The version of decoder and encoder is not adapted.}
const
  NET_PALYM4_INIT_DECODER_ERROR = 519; {//Initialize decoder failed.}
const
  NET_PLAYM4_CHECK_FILE_ERROR = 520; {//The file data is unknown.}
const
  NET_PLAYM4_INIT_TIMER_ERROR = 521; {//Initialize multimedia clock failed.}
const
  NET_PLAYM4_BLT_ERROR = 522; {//Blt failed.}
const
  NET_PLAYM4_UPDATE_ERROR = 523; {//Update failed.}
const
  NET_PLAYM4_OPEN_FILE_ERROR_MULTI = 524; {//openfile error, streamtype is multi}
const
  NET_PLAYM4_OPEN_FILE_ERROR_VIDEO = 525; {//openfile error, streamtype is video}
const
  NET_PLAYM4_JPEG_COMPRESS_ERROR = 526; {//JPEG compress error}
const
  NET_PLAYM4_EXTRACT_NOT_SUPPORT = 527; {//Don't support the version of this file.}
const
  NET_PLAYM4_EXTRACT_DATA_ERROR = 528; {//extract video data failed.}

{+//******************全局错误码 end**********************/ }

{+//************************************************ }
{-NET_DVR_IsSupport()返回值 }
{-1－9位分别表示以下信息（位与是TRUE)表示支持； }
{=************************************************* }
const
  NET_DVR_SUPPORT_DDRAW = $01;{//支持DIRECTDRAW，如果不支持，则播放器不能工作；}
const
  NET_DVR_SUPPORT_BLT = $02;{//显卡支持BLT操作，如果不支持，则播放器不能工作；}
const
  NET_DVR_SUPPORT_BLTFOURCC = $04;{//显卡BLT支持颜色转换，如果不支持，播放器会用软件方法作RGB转换；}
const
  NET_DVR_SUPPORT_BLTSHRINKX = $08;{//显卡BLT支持X轴缩小；如果不支持，系统会用软件方法转换；}
const
  NET_DVR_SUPPORT_BLTSHRINKY = $10;{//显卡BLT支持Y轴缩小；如果不支持，系统会用软件方法转换；}
const
  NET_DVR_SUPPORT_BLTSTRETCHX = $20;{//显卡BLT支持X轴放大；如果不支持，系统会用软件方法转换；}
const
  NET_DVR_SUPPORT_BLTSTRETCHY = $40;{//显卡BLT支持Y轴放大；如果不支持，系统会用软件方法转换；}
const
  NET_DVR_SUPPORT_SSE = $80;{//CPU支持SSE指令，Intel Pentium3以上支持SSE指令；}
const
  NET_DVR_SUPPORT_MMX = $100;{//CPU支持MMX指令集，Intel Pentium3以上支持SSE指令；}

{+//*********************云台控制命令 begin*************************/ }
const
  LIGHT_PWRON = 2; {/* 接通灯光电源*/}
const
  WIPER_PWRON = 3; {/* 接通雨刷开关*/}
const
  FAN_PWRON = 4; {/* 接通风扇开关*/}
const
  HEATER_PWRON = 5; {/* 接通加热器开关*/}
const
  AUX_PWRON1 = 6; {/* 接通辅助设备开关*/}
const
  AUX_PWRON2 = 7; {/* 接通辅助设备开关*/}
const
  SET_PRESET = 8; {/* 设置预置点*/}
const
  CLE_PRESET = 9; {/* 清除预置点*/}

const
  ZOOM_IN = 11; {/* 焦距以速度SS变大(倍率变大)*/}
const
  ZOOM_OUT = 12; {/* 焦距以速度SS变小(倍率变小)*/}
const
  FOCUS_NEAR = 13; {/* 焦点以速度SS前调*/}
const
  FOCUS_FAR = 14; {/* 焦点以速度SS后调*/}
const
  IRIS_OPEN = 15; {/* 光圈以速度SS扩大*/}
const
  IRIS_CLOSE = 16; {/* 光圈以速度SS缩小*/}

const
  TILT_UP = 21; {/* 云台以SS的速度上仰*/}
const
  TILT_DOWN = 22; {/* 云台以SS的速度下俯*/}
const
  PAN_LEFT = 23; {/* 云台以SS的速度左转*/}
const
  PAN_RIGHT = 24; {/* 云台以SS的速度右转*/}
const
  UP_LEFT = 25; {/* 云台以SS的速度上仰和左转*/}
const
  UP_RIGHT = 26; {/* 云台以SS的速度上仰和右转*/}
const
  DOWN_LEFT = 27; {/* 云台以SS的速度下俯和左转*/}
const
  DOWN_RIGHT = 28; {/* 云台以SS的速度下俯和右转*/}
const
  PAN_AUTO = 29; {/* 云台以SS的速度左右自动扫描*/}

const
  FILL_PRE_SEQ = 30; {/* 将预置点加入巡航序列*/}
const
  SET_SEQ_DWELL = 31; {/* 设置巡航点停顿时间*/}
const
  SET_SEQ_SPEED = 32; {/* 设置巡航速度*/}
const
  CLE_PRE_SEQ = 33; {/* 将预置点从巡航序列中删除*/}
const
  STA_MEM_CRUISE = 34; {/* 开始记录轨迹*/}
const
  STO_MEM_CRUISE = 35; {/* 停止记录轨迹*/}
const
  RUN_CRUISE = 36; {/* 开始轨迹*/}
const
  RUN_SEQ = 37; {/* 开始巡航*/}
const
  STOP_SEQ = 38; {/* 停止巡航*/}
const
  GOTO_PRESET = 39; {/* 快球转到预置点*/}

{///海康IP快球 }
const
  SET_SEQ_START = 41; {/* 开始设置巡航*/}
const
  SET_SEQ_END = 42; {/* 结束设置巡航*/}
{+//*********************云台控制命令 end*************************/ }

{+//************************************************ }
{-回放时播放控制命令宏定义 }
{-NET_DVR_PlayBackControl }
{-NET_DVR_PlayControlLocDisplay }
{-NET_DVR_DecPlayBackCtrl的宏定义 }
{-具体支持查看函数说明和代码 }
{=************************************************* }
const
  NET_DVR_PLAYSTART =1;{//开始播放}
const
  NET_DVR_PLAYSTOP =2;{//停止播放}
const
  NET_DVR_PLAYPAUSE =3;{//暂停播放}
const
  NET_DVR_PLAYRESTART =4;{//恢复播放}
const
  NET_DVR_PLAYFAST =5;{//快放}
const
  NET_DVR_PLAYSLOW =6;{//慢放}
const
  NET_DVR_PLAYNORMAL =7;{//正常速度}
const
  NET_DVR_PLAYFRAME =8;{//单帧放}
const
  NET_DVR_PLAYSTARTAUDIO =9;{//打开声音}
const
  NET_DVR_PLAYSTOPAUDIO = 10;{//关闭声音}
const
  NET_DVR_PLAYAUDIOVOLUME = 11;{//调节音量}
const
  NET_DVR_PLAYSETPOS = 12;{//改变文件回放的进度}
const
  NET_DVR_PLAYGETPOS = 13;{//获取文件回放的进度}
const
  NET_DVR_PLAYGETTIME = 14;{//获取当前已经播放的时间(按文件回放的时候有效)}
const
  NET_DVR_PLAYGETFRAME = 15;{//获取当前已经播放的帧数(按文件回放的时候有效)}
const
  NET_DVR_GETTOTALFRAMES = 16;{//获取当前播放文件总的帧数(按文件回放的时候有效)}
const
  NET_DVR_GETTOTALTIME = 17;{//获取当前播放文件总的时间(按文件回放的时候有效)}
//const
  //NET_DVR_THROWBFRAME = 20;{//丢B帧}
const
  NET_DVR_SETSPEED = 24;{//设置码流速度}
const
  NET_DVR_KEEPALIVE = 25;{//保持与设备的心跳(如果回调阻塞，建议2秒发送一次)}

{///远程按键定义如下： }
{+// key value send to CONFIG program*/ }
const
  KEY_CODE_1 = 1;
const
  KEY_CODE_2 = 2;
const
  KEY_CODE_3 = 3;
const
  KEY_CODE_4 = 4;
const
  KEY_CODE_5 = 5;
const
  KEY_CODE_6 = 6;
const
  KEY_CODE_7 = 7;
const
  KEY_CODE_8 = 8;
const
  KEY_CODE_9 = 9;
const
  KEY_CODE_0 = 10;
const
  KEY_CODE_POWER = 11;
const
  KEY_CODE_MENU = 12;
const
  KEY_CODE_ENTER = 13;
const
  KEY_CODE_CANCEL = 14;
const
  KEY_CODE_UP = 15;
const
  KEY_CODE_DOWN = 16;
const
  KEY_CODE_LEFT = 17;
const
  KEY_CODE_RIGHT = 18;
const
  KEY_CODE_EDIT = 19;
const
  KEY_CODE_ADD = 20;
const
  KEY_CODE_MINUS = 21;
const
  KEY_CODE_PLAY = 22;
const
  KEY_CODE_REC = 23;
const
  KEY_CODE_PAN = 24;
const
  KEY_CODE_M = 25;
const
  KEY_CODE_A = 26;
const
  KEY_CODE_F1 = 27;
const
  KEY_CODE_F2 = 28;

{+// for PTZ control*/ }
const
  KEY_PTZ_UP_START = KEY_CODE_UP;
const
  KEY_PTZ_UP_STOP = 32;

const
  KEY_PTZ_DOWN_START = KEY_CODE_DOWN;
const
  KEY_PTZ_DOWN_STOP = 33;

const
  KEY_PTZ_LEFT_START = KEY_CODE_LEFT;
const
  KEY_PTZ_LEFT_STOP = 34;

const
  KEY_PTZ_RIGHT_START = KEY_CODE_RIGHT;
const
  KEY_PTZ_RIGHT_STOP = 35;

const
  KEY_PTZ_AP1_START = KEY_CODE_EDIT; {/* 光圈+*/}
const
  KEY_PTZ_AP1_STOP = 36;

const
  KEY_PTZ_AP2_START = KEY_CODE_PAN; {/* 光圈-*/}
const
  KEY_PTZ_AP2_STOP = 37;

const
  KEY_PTZ_FOCUS1_START = KEY_CODE_A; {/* 聚焦+*/}
const
  KEY_PTZ_FOCUS1_STOP = 38;

const
  KEY_PTZ_FOCUS2_START = KEY_CODE_M; {/* 聚焦-*/}
const
  KEY_PTZ_FOCUS2_STOP = 39;

const
  KEY_PTZ_B1_START = 40; {/* 变倍+*/}
const
  KEY_PTZ_B1_STOP = 41;

const
  KEY_PTZ_B2_START = 42; {/* 变倍-*/}
const
  KEY_PTZ_B2_STOP = 43;

{///9000新增 }
const
  KEY_CODE_11 = 44;
const
  KEY_CODE_12 = 45;
const
  KEY_CODE_13 = 46;
const
  KEY_CODE_14 = 47;
const
  KEY_CODE_15 = 48;
const
  KEY_CODE_16 = 49;

{+//************************参数配置命令 begin*******************************/ }
{///用于NET_DVR_SetDVRConfig和NET_DVR_GetDVRConfig,注意其对应的配置结构 }

const
  NET_DVR_GET_DEVICECFG = 100; {//获取设备参数}
const
  NET_DVR_SET_DEVICECFG = 101; {//设置设备参数}
const
  NET_DVR_GET_NETCFG = 102; {//获取网络参数}
const
  NET_DVR_SET_NETCFG = 103; {//设置网络参数}
const
  NET_DVR_GET_PICCFG = 104; {//获取图象参数}
const
  NET_DVR_SET_PICCFG = 105; {//设置图象参数}
const
  NET_DVR_GET_COMPRESSCFG = 106; {//获取压缩参数}
const
  NET_DVR_SET_COMPRESSCFG = 107; {//设置压缩参数}
const
  NET_DVR_GET_RECORDCFG = 108; {//获取录像时间参数}
const
  NET_DVR_SET_RECORDCFG = 109; {//设置录像时间参数}
const
  NET_DVR_GET_DECODERCFG = 110; {//获取解码器参数}
const
  NET_DVR_SET_DECODERCFG = 111; {//设置解码器参数}
const
  NET_DVR_GET_RS232CFG = 112; {//获取232串口参数}
const
  NET_DVR_SET_RS232CFG = 113; {//设置232串口参数}
const
  NET_DVR_GET_ALARMINCFG = 114; {//获取报警输入参数}
const
  NET_DVR_SET_ALARMINCFG = 115; {//设置报警输入参数}
const
  NET_DVR_GET_ALARMOUTCFG = 116; {//获取报警输出参数}
const
  NET_DVR_SET_ALARMOUTCFG = 117; {//设置报警输出参数}
const
  NET_DVR_GET_TIMECFG = 118; {//获取DVR时间}
const
  NET_DVR_SET_TIMECFG = 119; {//设置DVR时间}
const
  NET_DVR_GET_PREVIEWCFG = 120; {//获取预览参数}
const
  NET_DVR_SET_PREVIEWCFG = 121; {//设置预览参数}
const
  NET_DVR_GET_VIDEOOUTCFG = 122; {//获取视频输出参数}
const
  NET_DVR_SET_VIDEOOUTCFG = 123; {//设置视频输出参数}
const
  NET_DVR_GET_USERCFG = 124; {//获取用户参数}
const
  NET_DVR_SET_USERCFG = 125; {//设置用户参数}
const
  NET_DVR_GET_EXCEPTIONCFG = 126; {//获取异常参数}
const
  NET_DVR_SET_EXCEPTIONCFG = 127; {//设置异常参数}
const
  NET_DVR_GET_ZONEANDDST = 128; {//获取时区和夏时制参数}
const
  NET_DVR_SET_ZONEANDDST = 129; {//设置时区和夏时制参数}
const
  NET_DVR_GET_SHOWSTRING = 130; {//获取叠加字符参数}
const
  NET_DVR_SET_SHOWSTRING = 131; {//设置叠加字符参数}
const
  NET_DVR_GET_EVENTCOMPCFG = 132; {//获取事件触发录像参数}
const
  NET_DVR_SET_EVENTCOMPCFG = 133; {//设置事件触发录像参数}

const
  NET_DVR_GET_AUXOUTCFG = 140; {//获取报警触发辅助输出设置(HS设备辅助输出2006-02-28)}
const
  NET_DVR_SET_AUXOUTCFG = 141; {//设置报警触发辅助输出设置(HS设备辅助输出2006-02-28)}
const
  NET_DVR_GET_PREVIEWCFG_AUX = 142; {//获取-s系列双输出预览参数(-s系列双输出2006-04-13)}
const
  NET_DVR_SET_PREVIEWCFG_AUX = 143; {//设置-s系列双输出预览参数(-s系列双输出2006-04-13)}

const
  NET_DVR_GET_PICCFG_EX = 200; {//获取图象参数(SDK_V14扩展命令)}
const
  NET_DVR_SET_PICCFG_EX = 201; {//设置图象参数(SDK_V14扩展命令)}
const
  NET_DVR_GET_USERCFG_EX = 202; {//获取用户参数(SDK_V15扩展命令)}
const
  NET_DVR_SET_USERCFG_EX = 203; {//设置用户参数(SDK_V15扩展命令)}
const
  NET_DVR_GET_COMPRESSCFG_EX = 204; {//获取压缩参数(SDK_V15扩展命令2006-05-15)}
const
  NET_DVR_SET_COMPRESSCFG_EX = 205; {//设置压缩参数(SDK_V15扩展命令2006-05-15)}


const
  NET_DVR_GET_NETAPPCFG = 222; {//获取网络应用参数 NTP/DDNS/EMAIL}
const
  NET_DVR_SET_NETAPPCFG = 223; {//设置网络应用参数 NTP/DDNS/EMAIL}
const
  NET_DVR_GET_NTPCFG = 224; {//获取网络应用参数 NTP}
const
  NET_DVR_SET_NTPCFG = 225; {//设置网络应用参数 NTP}
const
  NET_DVR_GET_DDNSCFG = 226; {//获取网络应用参数 DDNS}
const
  NET_DVR_SET_DDNSCFG = 227; {//设置网络应用参数 DDNS}
{///对应NET_DVR_EMAILPARA }
const
  NET_DVR_GET_EMAILCFG = 228; {//获取网络应用参数 EMAIL}
const
  NET_DVR_SET_EMAILCFG = 229; {//设置网络应用参数 EMAIL}

const
  NET_DVR_GET_NFSCFG = 230; {/* NFS disk config*/}
const
  NET_DVR_SET_NFSCFG = 231; {/* NFS disk config*/}

const
  NET_DVR_GET_SHOWSTRING_EX = 238; {//获取叠加字符参数扩展(支持8条字符)}
const
  NET_DVR_SET_SHOWSTRING_EX = 239; {//设置叠加字符参数扩展(支持8条字符)}
const
  NET_DVR_GET_NETCFG_OTHER = 244; {//获取网络参数(多路解码器)}
const
  NET_DVR_SET_NETCFG_OTHER = 245; {//设置网络参数(多路解码器)}

{///对应NET_DVR_EMAILCFG结构 }
const
  NET_DVR_GET_EMAILPARACFG = 250; {//Get EMAIL parameters}
const
  NET_DVR_SET_EMAILPARACFG = 251; {//Setup EMAIL parameters}


const
  NET_DVR_GET_DDNSCFG_EX = 274; {//获取扩展DDNS参数}
const
  NET_DVR_SET_DDNSCFG_EX = 275; {//设置扩展DDNS参数}

const
  NET_DVR_SET_PTZPOS = 292; {//云台设置PTZ位置}
const
  NET_DVR_GET_PTZPOS = 293; {//云台获取PTZ位置}
const
  NET_DVR_GET_PTZSCOPE = 294; {//云台获取PTZ范围}

{/// }
const
  NET_DVR_GET_ALLHDCFG = 300; {//}


{+//**************************DS9000新增命令(_V30) begin*****************************/ }
{///网络(NET_DVR_NETCFG_V30结构) }
const
  NET_DVR_GET_NETCFG_V30 = 1000; {//获取网络参数}
const
  NET_DVR_SET_NETCFG_V30 = 1001; {//设置网络参数}

{///图象(NET_DVR_PICCFG_V30结构) }
const
  NET_DVR_GET_PICCFG_V30 = 1002; {//获取图象参数}
const
  NET_DVR_SET_PICCFG_V30 = 1003; {//设置图象参数}

{///录像时间(NET_DVR_RECORD_V30结构) }
const
  NET_DVR_GET_RECORDCFG_V30 = 1004; {//获取录像参数}
const
  NET_DVR_SET_RECORDCFG_V30 = 1005; {//设置录像参数}

{///用户(NET_DVR_USER_V30结构) }
const
  NET_DVR_GET_USERCFG_V30 = 1006; {//获取用户参数}
const
  NET_DVR_SET_USERCFG_V30 = 1007; {//设置用户参数}

{///9000DDNS参数配置(NET_DVR_DDNSPARA_V30结构) }
const
  NET_DVR_GET_DDNSCFG_V30 = 1010; {//获取DDNS(9000扩展)}
const
  NET_DVR_SET_DDNSCFG_V30 = 1011; {//设置DDNS(9000扩展)}

{///EMAIL功能(NET_DVR_EMAILCFG_V30结构) }
const
  NET_DVR_GET_EMAILCFG_V30 = 1012; {//获取EMAIL参数}
const
  NET_DVR_SET_EMAILCFG_V30 = 1013; {//设置EMAIL参数}

{///巡航参数 (NET_DVR_CRUISE_PARA结构) }
const
  NET_DVR_GET_CRUISE = 1020;
const
  NET_DVR_SET_CRUISE = 1021;


{///报警输入结构参数 (NET_DVR_ALARMINCFG_V30结构) }
const
  NET_DVR_GET_ALARMINCFG_V30 = 1024;
const
  NET_DVR_SET_ALARMINCFG_V30 = 1025;

{///报警输出结构参数 (NET_DVR_ALARMOUTCFG_V30结构) }
const
  NET_DVR_GET_ALARMOUTCFG_V30 = 1026;
const
  NET_DVR_SET_ALARMOUTCFG_V30 = 1027;

{///视频输出结构参数 (NET_DVR_VIDEOOUT_V30结构) }
const
  NET_DVR_GET_VIDEOOUTCFG_V30 = 1028;
const
  NET_DVR_SET_VIDEOOUTCFG_V30 = 1029;

{///叠加字符结构参数 (NET_DVR_SHOWSTRING_V30结构) }
const
  NET_DVR_GET_SHOWSTRING_V30 = 1030;
const
  NET_DVR_SET_SHOWSTRING_V30 = 1031;

{///异常结构参数 (NET_DVR_EXCEPTION_V30结构) }
const
  NET_DVR_GET_EXCEPTIONCFG_V30 = 1034;
const
  NET_DVR_SET_EXCEPTIONCFG_V30 = 1035;

{///串口232结构参数 (NET_DVR_RS232CFG_V30结构) }
const
  NET_DVR_GET_RS232CFG_V30 = 1036;
const
  NET_DVR_SET_RS232CFG_V30 = 1037;

{///压缩参数 (NET_DVR_COMPRESSIONCFG_V30结构) }
const
  NET_DVR_GET_COMPRESSCFG_V30 = 1040;
const
  NET_DVR_SET_COMPRESSCFG_V30 = 1041;

{///获取485解码器参数 (NET_DVR_DECODERCFG_V30结构) }
const
  NET_DVR_GET_DECODERCFG_V30 = 1042; {//获取解码器参数}
const
  NET_DVR_SET_DECODERCFG_V30 = 1043; {//设置解码器参数}

{///获取预览参数 (NET_DVR_PREVIEWCFG_V30结构) }
const
  NET_DVR_GET_PREVIEWCFG_V30 = 1044; {//获取预览参数}
const
  NET_DVR_SET_PREVIEWCFG_V30 = 1045; {//设置预览参数}

{///辅助预览参数 (NET_DVR_PREVIEWCFG_AUX_V30结构) }
const
  NET_DVR_GET_PREVIEWCFG_AUX_V30 = 1046; {//获取辅助预览参数}
const
  NET_DVR_SET_PREVIEWCFG_AUX_V30 = 1047; {//设置辅助预览参数}

{///IP接入配置参数 （NET_DVR_IPPARACFG结构） }
const
  NET_DVR_GET_IPPARACFG = 1048; {//获取IP接入配置信息}
const
  NET_DVR_SET_IPPARACFG = 1049; {//设置IP接入配置信息}

{///IP报警输入接入配置参数 （NET_DVR_IPALARMINCFG结构） }
const
  NET_DVR_GET_IPALARMINCFG = 1050; {//获取IP报警输入接入配置信息}
const
  NET_DVR_SET_IPALARMINCFG = 1051; {//设置IP报警输入接入配置信息}

{///IP报警输出接入配置参数 （NET_DVR_IPALARMOUTCFG结构） }
const
  NET_DVR_GET_IPALARMOUTCFG = 1052; {//获取IP报警输出接入配置信息}
const
  NET_DVR_SET_IPALARMOUTCFG = 1053; {//设置IP报警输出接入配置信息}

{///硬盘管理的参数获取 (NET_DVR_HDCFG结构) }
const
  NET_DVR_GET_HDCFG = 1054; {//获取硬盘管理配置参数}
const
  NET_DVR_SET_HDCFG = 1055; {//设置硬盘管理配置参数}
{///盘组管理的参数获取 (NET_DVR_HDGROUP_CFG结构) }
const
  NET_DVR_GET_HDGROUP_CFG = 1056; {//获取盘组管理配置参数}
const
  NET_DVR_SET_HDGROUP_CFG = 1057; {//设置盘组管理配置参数}

{///设备编码类型配置(NET_DVR_COMPRESSION_AUDIO结构) }
const
  NET_DVR_GET_COMPRESSCFG_AUD = 1058; {//获取设备语音对讲编码参数}
const
  NET_DVR_SET_COMPRESSCFG_AUD = 1059; {//设置设备语音对讲编码参数}
const NET_DVR_GET_LIGHTSNAPCFG = 1076;
const NET_DVR_SET_LIGHTSNAPCFG =1077;
const   NET_DVR_GET_SPRCFG  = 1092;  //获取智能高清网络摄像机车牌识别参数
const   NET_DVR_SET_SPRCFG  = 1093;  //设置智能高清网络摄像机车牌识别参数

const MAX_LICENSE_LEN =16;   //车牌号最大长度
{+//**************************DS9000新增命令(_V30) end*****************************/ }

{+//************************参数配置命令 end*******************************/ }


{+//******************查找文件和日志函数返回值*************************/ }
const
  NET_DVR_FILE_SUCCESS = 1000; {//获得文件信息}
const
  NET_DVR_FILE_NOFIND = 1001; {//没有文件}
const
  NET_DVR_ISFINDING = 1002; {//正在查找文件}
const
  NET_DVR_NOMOREFILE = 1003; {//查找文件时没有更多的文件}
const
  NET_DVR_FILE_EXCEPTION = 1004; {//查找文件时异常}

{+//********************回调函数类型 begin************************/ }
const
  COMM_ALARM = $1100; {//8000报警信息主动上传}
const
  COMM_TRADEINFO = $1500; {//ATMDVR主动上传交易信息}
const
  COMM_UPLOAD_PLATE_RESULT = $2800;
const
  COMM_ALARM_V30 = $4000; {//9000报警信息主动上传}
const
  COMM_IPCCFG = $4001; {//9000设备IPC接入配置改变报警信息主动上传}


{+//************操作异常类型(消息方式, 回调方式(保留))****************/ }
const
  EXCEPTION_EXCHANGE = $8000; {//用户交互时异常}
const
  EXCEPTION_AUDIOEXCHANGE = $8001; {//语音对讲异常}
const
  EXCEPTION_ALARM = $8002; {//报警异常}
const
  EXCEPTION_PREVIEW = $8003; {//网络预览异常}
const
  EXCEPTION_SERIAL = $8004; {//透明通道异常}
const
  EXCEPTION_RECONNECT = $8005; {//预览时重连}
const
  EXCEPTION_ALARMRECONNECT = $8006; {//报警时重连}
const
  EXCEPTION_SERIALRECONNECT = $8007; {//透明通道重连}
const
  EXCEPTION_PLAYBACK = $8010; {//回放异常}
const
  EXCEPTION_DISKFMT = $8011; {//硬盘格式化}

{+//*******************预览回调函数*********************/ }
const
  NET_DVR_SYSHEAD = 1; {//系统头数据}
const
  NET_DVR_STREAMDATA = 2; {//视频流数据（包括复合流和音视频分开的视频流数据）}
const
  NET_DVR_AUDIOSTREAMDATA = 3; {//音频流数据}
const
  NET_DVR_STD_VIDEODATA = 4; {//标准视频流数据}
const
  NET_DVR_STD_AUDIODATA = 5; {//标准音频流数据}

{///回调预览中的状态和消息 }
const
  NET_DVR_REALPLAYEXCEPTION = 111; {//预览异常}
const
  NET_DVR_REALPLAYNETCLOSE = 112; {//预览时连接断开}
const
  NET_DVR_REALPLAY5SNODATA = 113; {//预览5s没有收到数据}
const
  NET_DVR_REALPLAYRECONNECT = 114; {//预览重连}

{+//*******************回放回调函数*********************/ }
const
  NET_DVR_PLAYBACKOVER = 101; {//回放数据播放完毕}
const
  NET_DVR_PLAYBACKEXCEPTION = 102; {//回放异常}
const
  NET_DVR_PLAYBACKNETCLOSE = 103; {//回放时候连接断开}
const
  NET_DVR_PLAYBACK5SNODATA = 104; {//回放5s没有收到数据}

{+//********************回调函数类型 end************************/ }


{///设备型号(DVR类型) }
{+// 设备类型*/ }
const
  DVR = 1; {/*对尚未定义的dvr类型返回NETRET_DVR*/}
const
  ATMDVR = 2; {/*atm dvr*/}
const
  DVS = 3; {/*DVS*/}
const
  DEC = 4; {/* 6001D*/}
const
  ENC_DEC = 5; {/* 6001F*/}
const
  DVR_HC = 6; {/*8000HC*/}
const
  DVR_HT = 7; {/*8000HT*/}
const
  DVR_HF = 8; {/*8000HF*/}
const
  DVR_HS = 9; {/* 8000HS DVR(no audio)*/}
const
  DVR_HTS = 10; {/* 8016HTS DVR(no audio)*/}
const
  DVR_HB = 11; {/* HB DVR(SATA HD)*/}
const
  DVR_HCS = 12; {/* 8000HCS DVR*/}
const
  DVS_A = 13; {/* 带ATA硬盘的DVS*/}
const
  DVR_HC_S = 14; {/* 8000HC-S*/}
const
  DVR_HT_S = 15; {/* 8000HT-S*/}
const
  DVR_HF_S = 16; {/* 8000HF-S*/}
const
  DVR_HS_S = 17; {/* 8000HS-S*/}
const
  ATMDVR_S = 18; {/* ATM-S*/}
const
  LOWCOST_DVR = 19; {/*7000H系列*/}
const
  DEC_MAT = 20; {/*多路解码器*/}
const
  DVR_MOBILE = 21; {/* mobile DVR*/}
const
  DVR_HD_S = 22; {/* 8000HD-S*/}
const
  DVR_HD_SL = 23; {/* 8000HD-SL*/}
const
  DVR_HC_SL = 24; {/* 8000HC-SL*/}
const
  DVR_HS_ST = 25; {/* 8000HS_ST*/}
const
  DVS_HW = 26; {/* 6000HW*/}
const
  IPCAM = 30; {/*IP 摄像机*/}
const
  MEGA_IPCAM = 31; {/*X52MF系列,752MF,852MF*/}
const
  IPCAM_X62MF = 32; {/*X62MF系列可接入9000设备,762MF,862MF*/}
const
  IPDOME = 40; {/*IP 快球*/}
const
  IPMOD = 50; {/*IP 模块*/}
const
  DS71XX_H = 71; {/*71XX*/}
const
  DS81XX_HS_S = 80; {/*DS81XX_HS_S*/}
const
  DS90XX_HF_S = 90; {/*DS90XX_HF_S*/}
const
  DS91XX_HF_S = 91; {/*DS91XX_HF_S*/}
const
  DS91XX_HD_S = 92; {/*91XXHD-S(MD)*/}


{+//*********************设备类型 end***********************/ }

{+//************************************************ }
{-参数配置结构、参数(其中_V30为9000新增) }
{=************************************************* }

{////////////////////////////////////////////////////////////////////////// }
{///校时结构参数 }
type
  NET_DVR_TIME = record
    dwYear: LongInt;
    dwMonth: LongInt;
    dwDay: LongInt;
    dwHour: LongInt;
    dwMinute: LongInt;
    dwSecond: LongInt;
  end {NET_DVR_TIME};
  LPNET_DVR_TIME = ^NET_DVR_TIME;

{///时间段(子结构) }
type
  NET_DVR_SCHEDTIME = record
{///开始时间 }
    byStartHour: BYTE;
    byStartMin: BYTE;
{///结束时间 }
    byStopHour: BYTE;
    byStopMin: BYTE;
  end {NET_DVR_SCHEDTIME};
  LPNET_DVR_SCHEDTIME = ^NET_DVR_SCHEDTIME;

{+//设备报警和异常处理方式*/ }
const
  NOACTION = $0; {/*无响应*/}
const
  WARNONMONITOR = $1; {/*监视器上警告*/}
const
  WARNONAUDIOOUT = $2; {/*声音警告*/}
const
  UPTOCENTER = $4; {/*上传中心*/}
const
  TRIGGERALARMOUT = $8; {/*触发报警输出*/}

{///报警和异常处理结构(子结构)(多处使用)(9000扩展) }
type
  NET_DVR_HANDLEEXCEPTION_V30 = record
    dwHandleType: LongInt;
{=处理方式,处理方式的"或"结果 }
{+//0x00: 无响应*/ }
{+//0x01: 监视器上警告*/ }
{+//0x02: 声音警告*/ }
{+//0x04: 上传中心*/ }
{+//0x08: 触发报警输出*/ }
{+//0x10: Jpeg抓图并上传EMail*/ }
    byRelAlarmOut: Array[0..MAX_ALARMOUT_V30-1] of BYTE;
{///报警触发的输出通道,报警触发的输出,为1表示触发该输出 }
  end {NET_DVR_HANDLEEXCEPTION_V30};
  LPNET_DVR_HANDLEEXCEPTION_V30 = ^NET_DVR_HANDLEEXCEPTION_V30;

{///报警和异常处理结构(子结构)(多处使用) }
type
  NET_DVR_HANDLEEXCEPTION = record
    dwHandleType: LongInt;
{=处理方式,处理方式的"或"结果 }
{+//0x00: 无响应*/ }
{+//0x01: 监视器上警告*/ }
{+//0x02: 声音警告*/ }
{+//0x04: 上传中心*/ }
{+//0x08: 触发报警输出*/ }
{+//0x10: Jpeg抓图并上传EMail*/ }
    byRelAlarmOut: Array[0..MAX_ALARMOUT-1] of BYTE;
  end {NET_DVR_HANDLEEXCEPTION};
  LPNET_DVR_HANDLEEXCEPTION = ^NET_DVR_HANDLEEXCEPTION;

{///DVR设备参数 }     
type
  NET_DVR_DEVICECFG = record
    dwSize: LongInt;
    sDVRName: Array[0..NAME_LEN-1] of BYTE;
    dwDVRID: LongInt;
    dwRecycleRecord: LongInt;
{///以下不可更改 }
    sSerialNumber: Array[0..SERIALNO_LEN-1] of BYTE;
    dwSoftwareVersion: LongInt;
    dwSoftwareBuildDate: LongInt;
    dwDSPSoftwareVersion: LongInt;
    dwDSPSoftwareBuildDate: LongInt;
    dwPanelVersion: LongInt;
    dwHardwareVersion: LongInt;
    byAlarmInPortNum: BYTE;
    byAlarmOutPortNum: BYTE;
    byRS232Num: BYTE;
    byRS485Num: BYTE;
    byNetworkPortNum: BYTE;
    byDiskCtrlNum: BYTE;
    byDiskNum: BYTE;
    byDVRType: BYTE;
    byChanNum: BYTE;
    byStartChan: BYTE;
    byDecordChans: BYTE;
    byVGANum: BYTE;
    byUSBNum: BYTE;
    byAuxoutNum: BYTE;
    byAudioNum: BYTE;
    byIPChanNum: BYTE;
  end {NET_DVR_DEVICECFG};
  LPNET_DVR_DEVICECFG = ^NET_DVR_DEVICECFG;

{+// }
{-IP地址 }
{= }
type
  NET_DVR_IPADDR = record
    sIpV4: Array[0..16-1] of Char;
{= IPv4地址 }
    byRes: Array[0..128-1] of BYTE;
{= 保留 }
  end {NET_DVR_IPADDR};
  LPNET_DVR_IPADDR = ^NET_DVR_IPADDR;


{+// }
{-网络数据结构(子结构)(9000扩展) }
{= }
type
  NET_DVR_ETHERNET_V30 = record
    struDVRIP: NET_DVR_IPADDR;
    struDVRIPMask: NET_DVR_IPADDR;
    dwNetInterface: LongInt;
    wDVRPort: Word;
    wMTU: Word;
    byMACAddr: Array[0..MACADDR_LEN-1] of BYTE;
  end {NET_DVR_ETHERNET_V30};
  LPNET_DVR_ETHERNET_V30 = ^NET_DVR_ETHERNET_V30;

{+// }
{-网络数据结构(子结构) }
{= }
type
  NET_DVR_ETHERNET = record
    sDVRIP: Array[0..16-1] of Char;
    sDVRIPMask: Array[0..16-1] of Char;
    dwNetInterface: LongInt;
    wDVRPort: Word;
    byMACAddr: Array[0..MACADDR_LEN-1] of BYTE;
  end {NET_DVR_ETHERNET};

{///pppoe结构 }
type
  NET_DVR_PPPOECFG = record
    dwPPPOE: LongInt;
    sPPPoEUser: Array[0..NAME_LEN-1] of BYTE;
    sPPPoEPassword: Array[0..PASSWD_LEN-1] of Char;
    struPPPoEIP: NET_DVR_IPADDR;
  end {NET_DVR_PPPOECFG};
  LPNET_DVR_PPPOECFG = ^NET_DVR_PPPOECFG;

{///网络配置结构(9000扩展) }
type
  NET_DVR_NETCFG_V30 = record
    dwSize: LongInt;
    struEtherNet: Array[0..MAX_ETHERNET-1] of NET_DVR_ETHERNET_V30;
    struRes1: Array[0..2-1] of NET_DVR_IPADDR;
{=保留 }
    struAlarmHostIpAddr: NET_DVR_IPADDR;
{= 报警主机IP地址 }
    wRes2: Array[0..2-1] of Word;
{= 保留 }
    wAlarmHostIpPort: Word;
{= 报警主机端口号 }
    byUseDhcp: BYTE;
{= 是否启用DHCP 0xff-无效 0-不启用 1-启用 }
    byRes3: BYTE;
    struDnsServer1IpAddr: NET_DVR_IPADDR;
{= 域名服务器1的IP地址 }
    struDnsServer2IpAddr: NET_DVR_IPADDR;
{= 域名服务器2的IP地址 }
    byIpResolver: Array[0..MAX_DOMAIN_NAME-1] of BYTE;
{= IP解析服务器域名或IP地址 }
    wIpResolverPort: Word;
{= IP解析服务器端口号 }
    wHttpPortNo: Word;
{= HTTP端口号 }
    struMulticastIpAddr: NET_DVR_IPADDR;
{= 多播组地址 }
    struGatewayIpAddr: NET_DVR_IPADDR;
{= 网关地址 }
    struPPPoE: NET_DVR_PPPOECFG;
    byRes: Array[0..64-1] of BYTE;
  end {NET_DVR_NETCFG_V30};
  LPNET_DVR_NETCFG_V30 = ^NET_DVR_NETCFG_V30;

type
  NET_VCA_RECT = record
    fX:single;
    fy:single;
    fwidth:single;
    fheight:single;
  end ;
  LPNET_VCA_RECT = ^NET_VCA_RECT;

type
  NET_VCA_POINT = record
    fX:single;
    fy:single;
  end ;
  LPNET_VCA_POINT = ^NET_VCA_POINT;

type
  NET_ITC_POLYGON = record
    dwPointNum:LongInt;
    struPos:Array[0..20-1] of NET_VCA_POINT;
  end ;
  LPNET_ITC_POLYGON = ^NET_ITC_POLYGON;

type                  //智能高清网络摄像机红绿灯功能参数结构体。
  NET_DVR_LIGHTSNAPCFG = record

  dwSize:LongInt;
  byLightIoIn:byte;
  byTrigIoIn:byte;
  byRelatedDriveWay:byte;
  byTrafficLight:byte;
  bySnapTimes1:byte;
  bySnapTimes2:byte;
  byRes1:Array[0..1] of BYTE;
  wIntervalTime1:Array[0..MAX_INTERVAL_NUM-1]of word;
  wIntervalTime2:Array[0..MAX_INTERVAL_NUM-1]of word;
  byRecord:byte;
  bySessionTimeout:byte;
  byPreRecordTime:byte;
  byVideoDelay:byte;
  byRes2:Array[0..31] of BYTE;
end;
LPNET_DVR_LIGHTSNAPCFG = ^NET_DVR_LIGHTSNAPCFG;


type                  //智能高清网络摄像机车牌识别参数结构体。
  NET_DVR_SPRCFG = record
  dwSize:longword;
  byDefaultCHN:array[0..MAX_CHJC_NUM-1] of BYTE;
  byPlateOSD:Byte;
  bySendJPEG1:BYTE;
  bySendJPEG2:BYTE;
  wDesignedPlateWidth:Word;
  byTotalLaneNum:BYTE;
  byRes1:BYTE;
  wRecognizedLane:WORD;
  struLaneRect:array[0..MAX_LANERECT_NUM-1] of NET_VCA_RECT;
  dwRecogMode:LongWord;
  byRes2:array[0..71] of byte;

end;
LPNET_DVR_SPRCFG = ^NET_DVR_SPRCFG;


{///网络配置结构 }
type
  NET_DVR_NETCFG = record
    dwSize: LongInt;
    struEtherNet: Array[0..MAX_ETHERNET-1] of NET_DVR_ETHERNET;
{= 以太网口 }
    sManageHostIP: Array[0..16-1] of Char;
    wManageHostPort: Word;
    sIPServerIP: Array[0..16-1] of Char;
    sMultiCastIP: Array[0..16-1] of Char;
    sGatewayIP: Array[0..16-1] of Char;
    sNFSIP: Array[0..16-1] of Char;
    sNFSDirectory: Array[0..PATHNAME_LEN-1] of BYTE;
    dwPPPOE: LongInt;
    sPPPoEUser: Array[0..NAME_LEN-1] of BYTE;
    sPPPoEPassword: Array[0..PASSWD_LEN-1] of Char;
    sPPPoEIP: Array[0..16-1] of Char;
    wHttpPort: Word;
  end {NET_DVR_NETCFG};
  LPNET_DVR_NETCFG = ^NET_DVR_NETCFG;

{///通道图象结构 }
{///移动侦测(子结构)(9000扩展) }
type
  NET_DVR_MOTION_V30 = record
    byMotionScope: Array[0..63,0..95] of BYTE;
{=侦测区域,0-96位,表示64行,共有96*64个小宏块,为1表示是移动侦测区域,0-表示不是 }
    byMotionSensitive: BYTE;
{=移动侦测灵敏度, 0 - 5,越高越灵敏,oxff关闭 }
    byEnableHandleMotion: BYTE;
{= 是否处理移动侦测 0－否 1－是 }
    byPrecision: BYTE;
{= 移动侦测算法的进度: 0--16*16, 1--32*32, 2--64*64 ... }
    reservedData: Char;
    struMotionHandleType: NET_DVR_HANDLEEXCEPTION_V30;
{= 处理方式 }
    struAlarmTime: Array[0..MAX_DAYS-1,0..MAX_TIMESEGMENT_V30-1] of NET_DVR_SCHEDTIME;
{=布防时间 }
    byRelRecordChan: Array[0..MAX_CHANNUM_V30-1] of BYTE;
{= 报警触发的录象通道 }
  end {NET_DVR_MOTION_V30};
  LPNET_DVR_MOTION_V30 = ^NET_DVR_MOTION_V30;

{///移动侦测(子结构) }
type
  NET_DVR_MOTION = record
    byMotionScope: Array[0..17,0..22-1] of BYTE;
{=侦测区域,共有22*18个小宏块,为1表示改宏块是移动侦测区域,0-表示不是 }
    byMotionSensitive: BYTE;
{=移动侦测灵敏度, 0 - 5,越高越灵敏,0xff关闭 }
    byEnableHandleMotion: BYTE;
{= 是否处理移动侦测 }
    reservedData: Array[0..2-1] of Char;
    strMotionHandleType:  NET_DVR_HANDLEEXCEPTION ;
{= 处理方式 }
    struAlarmTime: Array[0..MAX_DAYS-1,0..MAX_TIMESEGMENT-1] of NET_DVR_SCHEDTIME;
    byRelRecordChan: Array[0..MAX_CHANNUM-1] of BYTE;
  end {NET_DVR_MOTION};
  LPNET_DVR_MOTION = ^NET_DVR_MOTION;

{///遮挡报警(子结构)(9000扩展) 区域大小704*576 }
type
  NET_DVR_HIDEALARM_V30 = record
    dwEnableHideAlarm: LongInt;
{= 是否启动遮挡报警 ,0-否,1-低灵敏度 2-中灵敏度 3-高灵敏度 }
    wHideAlarmAreaTopLeftX: Word;
{= 遮挡区域的x坐标 }
    wHideAlarmAreaTopLeftY: Word;
{= 遮挡区域的y坐标 }
    wHideAlarmAreaWidth: Word;
{= 遮挡区域的宽 }
    wHideAlarmAreaHeight: Word;
{=遮挡区域的高 }
    strHideAlarmHandleType: NET_DVR_HANDLEEXCEPTION_V30;
{= 处理方式 }
    struAlarmTime: Array[0..MAX_DAYS-1,0..MAX_TIMESEGMENT_V30-1] of NET_DVR_SCHEDTIME;
  end {NET_DVR_HIDEALARM_V30};
  LPNET_DVR_HIDEALARM_V30 = ^NET_DVR_HIDEALARM_V30;
{///遮挡报警(子结构) 区域大小704*576 }
type
  NET_DVR_HIDEALARM = record
    dwEnableHideAlarm: LongInt;
{= 是否启动遮挡报警 ,0-否,1-低灵敏度 2-中灵敏度 3-高灵敏度 }
    wHideAlarmAreaTopLeftX: Word;
{= 遮挡区域的x坐标 }
    wHideAlarmAreaTopLeftY: Word;
{= 遮挡区域的y坐标 }
    wHideAlarmAreaWidth: Word;
{= 遮挡区域的宽 }
    wHideAlarmAreaHeight: Word;
{=遮挡区域的高 }
    strHideAlarmHandleType: NET_DVR_HANDLEEXCEPTION;
{= 处理方式 }
    struAlarmTime: Array[0..MAX_DAYS-1,0..MAX_TIMESEGMENT-1] of NET_DVR_SCHEDTIME;
  end {NET_DVR_HIDEALARM};
  LPNET_DVR_HIDEALARM = ^NET_DVR_HIDEALARM;

{///信号丢失报警(子结构)(9000扩展) }
type
  NET_DVR_VILOST_V30 = record
    byEnableHandleVILost: BYTE;
{= 是否处理信号丢失报警 }
    strVILostHandleType: NET_DVR_HANDLEEXCEPTION_V30;
{= 处理方式 }
    struAlarmTime: Array[0..MAX_DAYS-1,0..MAX_TIMESEGMENT_V30-1] of NET_DVR_SCHEDTIME;
  end {NET_DVR_VILOST_V30};
  LPNET_DVR_VILOST_V30 = ^NET_DVR_VILOST_V30;

{///信号丢失报警(子结构) }
type
  NET_DVR_VILOST = record
    byEnableHandleVILost: BYTE;
{= 是否处理信号丢失报警 }
     strVILostHandleType: NET_DVR_HANDLEEXCEPTION;
{= 处理方式 }
    struAlarmTime: Array[0..MAX_DAYS-1,0..MAX_TIMESEGMENT-1] of NET_DVR_SCHEDTIME;
  end {NET_DVR_VILOST};
  LPNET_DVR_VILOST = ^NET_DVR_VILOST;

{///遮挡区域(子结构) }
type
  NET_DVR_SHELTER = record
    wHideAreaTopLeftX: Word;
{= 遮挡区域的x坐标 }
    wHideAreaTopLeftY: Word;
{= 遮挡区域的y坐标 }
    wHideAreaWidth: Word;
{= 遮挡区域的宽 }
    wHideAreaHeight: Word;
{=遮挡区域的高 }
  end {NET_DVR_SHELTER};
  LPNET_DVR_SHELTER = ^NET_DVR_SHELTER;

type
  NET_DVR_COLOR = record
    byBrightness: BYTE;
{=亮度,0-255 }
    byContrast: BYTE;
{=对比度,0-255 }
    bySaturation: BYTE;
{=饱和度,0-255 }
    byHue: BYTE;
{=色调,0-255 }
  end {NET_DVR_COLOR};
  LPNET_DVR_COLOR = ^NET_DVR_COLOR;


{///通道图象结构(9000扩展) }
type
  NET_DVR_PICCFG_V30 = record
    dwSize: LongInt;
    sChanName: Array[0..NAME_LEN-1] of BYTE;
    dwVideoFormat: LongInt;
{= 只读 视频制式 1-NTSC 2-PAL }
    struColor: NET_DVR_COLOR;
    reservedData: Array[0..60-1] of CHAR;
{=保留 }
{///显示通道名 }
    dwShowChanName: LongInt;
    wShowNameTopLeftX: Word;
{= 通道名称显示位置的x坐标 }
    wShowNameTopLeftY: Word;
{= 通道名称显示位置的y坐标 }
{///视频信号丢失报警 }
    struVILost: NET_DVR_VILOST_V30;
    struRes: NET_DVR_VILOST_V30;
{=保留 }
{///移动侦测 }
    struMotion: NET_DVR_MOTION_V30;
{///遮挡报警 }
    struHideAlarm: NET_DVR_HIDEALARM_V30;
{///遮挡 区域大小704*576 }
    dwEnableHide: LongInt;
{= 是否启动遮挡 ,0-否,1-是 }
     struShelter: Array[0..MAX_SHELTERNUM-1] of NET_DVR_SHELTER;
{///OSD }
    dwShowOsd: LongInt;
    wOSDTopLeftX: Word;
{= OSD的x坐标 }
    wOSDTopLeftY: Word;
{= OSD的y坐标 }
    byOSDType: BYTE;
{= OSD类型(主要是年月日格式) }
{+// 0: XXXX-XX-XX 年月日*/ }
{+// 1: XX-XX-XXXX 月日年*/ }
{+// 2: XXXX年XX月XX日*/ }
{+// 3: XX月XX日XXXX年*/ }
{+// 4: XX-XX-XXXX 日月年*/ }
{+// 5: XX日XX月XXXX年*/ }
    byDispWeek: BYTE;
{= 是否显示星期 }
    byOSDAttrib: BYTE;
{= OSD属性:透明，闪烁 }
{+// 0: 不显示OSD*/ }
{+// 1: 透明,闪烁*/ }
{+// 2: 透明,不闪烁*/ }
{+// 3: 闪烁,不透明*/ }
{+// 4: 不透明,不闪烁*/ }
    byHourOSDType: BYTE;
{= OSD小时制:0-24小时制,1-12小时制 }
    byRes: Array[0..64-1] of BYTE;
  end {NET_DVR_PICCFG_V30};
  LPNET_DVR_PICCFG_V30 = ^NET_DVR_PICCFG_V30;

{///通道图象结构SDK_V14扩展 }
type
  NET_DVR_PICCFG_EX = record
    dwSize: LongInt;
    sChanName: Array[0..NAME_LEN-1] of BYTE;
    dwVideoFormat: LongInt;
{= 只读 视频制式 1-NTSC 2-PAL }
    byBrightness: BYTE;
{=亮度,0-255 }
    byContrast: BYTE;
{=对比度,0-255 }
    bySaturation: BYTE;
{=饱和度,0-255 }
    byHue: BYTE;
{=色调,0-255 }
{///显示通道名 }
    dwShowChanName: LongInt;
    wShowNameTopLeftX: Word;
{= 通道名称显示位置的x坐标 }
    wShowNameTopLeftY: Word;
{= 通道名称显示位置的y坐标 }
{///信号丢失报警 }
    struVILost: NET_DVR_VILOST;
{///移动侦测 }
    struMotion: NET_DVR_MOTION;
{///遮挡报警 }
    struHideAlarm: NET_DVR_HIDEALARM;
{///遮挡 区域大小704*576 }
    dwEnableHide: LongInt;
{= 是否启动遮挡 ,0-否,1-是 }
     struShelter: Array[0..MAX_SHELTERNUM-1] of NET_DVR_SHELTER;
{///OSD }
    dwShowOsd: LongInt;
    wOSDTopLeftX: Word;
{= OSD的x坐标 }
    wOSDTopLeftY: Word;
{= OSD的y坐标 }
    byOSDType: BYTE;
{= OSD类型(主要是年月日格式) }
{+// 0: XXXX-XX-XX 年月日*/ }
{+// 1: XX-XX-XXXX 月日年*/ }
{+// 2: XXXX年XX月XX日*/ }
{+// 3: XX月XX日XXXX年*/ }
{+// 4: XX-XX-XXXX 日月年*/ }
{+// 5: XX日XX月XXXX年*/ }
    byDispWeek: BYTE;
{= 是否显示星期 }
    byOSDAttrib: BYTE;
{= OSD属性:透明，闪烁 }
{+// 0: 不显示OSD*/ }
{+// 1: 透明,闪烁*/ }
{+// 2: 透明,不闪烁*/ }
{+// 3: 闪烁,不透明*/ }
{+// 4: 不透明,不闪烁*/ }
    byHourOsdType: BYTE;
  end {NET_DVR_PICCFG_EX};
  LPNET_DVR_PICCFG_EX = ^NET_DVR_PICCFG_EX;

{///通道图象结构(SDK_V13及之前版本) }
type
  NET_DVR_PICCFG = record
    dwSize: LongInt;
    sChanName: Array[0..NAME_LEN-1] of BYTE;
    dwVideoFormat: LongInt;
{= 只读 视频制式 1-NTSC 2-PAL }
    byBrightness: BYTE;
{=亮度,0-255 }
    byContrast: BYTE;
{=对比度,0-255 }
    bySaturation: BYTE;
{=饱和度,0-255 }
    byHue: BYTE;
{=色调,0-255 }
{///显示通道名 }
    dwShowChanName: LongInt;
    wShowNameTopLeftX: Word;
{= 通道名称显示位置的x坐标 }
    wShowNameTopLeftY: Word;
{= 通道名称显示位置的y坐标 }
{///信号丢失报警 }
    struVILost: NET_DVR_VILOST;
{///移动侦测 }
    struMotion: NET_DVR_MOTION;
{///遮挡报警 }
    struHideAlarm: NET_DVR_HIDEALARM;
{///遮挡 区域大小704*576 }
    dwEnableHide: LongInt;
{= 是否启动遮挡 ,0-否,1-是 }
    wHideAreaTopLeftX: Word;
{= 遮挡区域的x坐标 }
    wHideAreaTopLeftY: Word;
{= 遮挡区域的y坐标 }
    wHideAreaWidth: Word;
{= 遮挡区域的宽 }
    wHideAreaHeight: Word;
{=遮挡区域的高 }
{///OSD }
    dwShowOsd: LongInt;
    wOSDTopLeftX: Word;
{= OSD的x坐标 }
    wOSDTopLeftY: Word;
{= OSD的y坐标 }
    byOSDType: BYTE;
{= OSD类型(主要是年月日格式) }
{+// 0: XXXX-XX-XX 年月日*/ }
{+// 1: XX-XX-XXXX 月日年*/ }
{+// 2: XXXX年XX月XX日*/ }
{+// 3: XX月XX日XXXX年*/ }
{+// 4: XX-XX-XXXX 日月年*/ }
{+// 5: XX日XX月XXXX年*/ }
    byDispWeek: BYTE;
{= 是否显示星期 }
    byOSDAttrib: BYTE;
{= OSD属性:透明，闪烁 }
{+// 0: 不显示OSD*/ }
{+// 1: 透明,闪烁*/ }
{+// 2: 透明,不闪烁*/ }
{+// 3: 闪烁,不透明*/ }
{+// 4: 不透明,不闪烁*/ }
    reservedData2: Char;
  end {NET_DVR_PICCFG};
  LPNET_DVR_PICCFG = ^NET_DVR_PICCFG;

{///码流压缩参数(子结构)(9000扩展) }
type
  NET_DVR_COMPRESSION_INFO_V30 = record
    byStreamType: BYTE;
    byResolution: BYTE;
    byBitrateType: BYTE;
    byPicQuality: BYTE;
    dwVideoBitrate: LongInt;
{/// 13-384K 14-448K 15-512K 16-640K 17-768K 18-896K 19-1024K 20-1280K 21-1536K 22-1792K 23-2048K }
{///最高位(31位)置成1表示是自定义码流, 0-30位表示码流值。 }
    dwVideoFrameRate: LongInt;
    wIntervalFrameI: Word;
{///2006-08-11 增加单P帧的配置接口，可以改善实时流延时问题 }
    byIntervalBPFrame: BYTE;
    byres1: BYTE;
    byVideoEncType: BYTE;
    byAudioEncType: BYTE;
    byres: Array[0..10-1] of BYTE;
  end {NET_DVR_COMPRESSION_INFO_V30};
  LPNET_DVR_COMPRESSION_INFO_V30 = ^NET_DVR_COMPRESSION_INFO_V30;

{///通道压缩参数(9000扩展) }
type
  NET_DVR_COMPRESSIONCFG_V30 = record
    dwSize: LongInt;
    struNormHighRecordPara: NET_DVR_COMPRESSION_INFO_V30;
    struNormLowRecordPara: NET_DVR_COMPRESSION_INFO_V30;
    struEventRecordPara: NET_DVR_COMPRESSION_INFO_V30;
    struNetPara: NET_DVR_COMPRESSION_INFO_V30;
  end {NET_DVR_COMPRESSIONCFG_V30};
  LPNET_DVR_COMPRESSIONCFG_V30 = ^NET_DVR_COMPRESSIONCFG_V30;

{///码流压缩参数(子结构) }
type
  NET_DVR_COMPRESSION_INFO = record
    byStreamType: BYTE;
    byResolution: BYTE;
    byBitrateType: BYTE;
    byPicQuality: BYTE;
    dwVideoBitrate: LongInt;
{/// 13-384K 14-448K 15-512K 16-640K 17-768K 18-896K 19-1024K 20-1280K 21-1536K 22-1792K 23-2048K }
{///最高位(31位)置成1表示是自定义码流, 0-30位表示码流值(MIN-32K MAX-8192K)。 }
    dwVideoFrameRate: LongInt;
  end {NET_DVR_COMPRESSION_INFO};
  LPNET_DVR_COMPRESSION_INFO = ^NET_DVR_COMPRESSION_INFO;

{///通道压缩参数 }
type
  NET_DVR_COMPRESSIONCFG = record
    dwSize: LongInt;
    struRecordPara: NET_DVR_COMPRESSION_INFO;
    struNetPara: NET_DVR_COMPRESSION_INFO;
  end {NET_DVR_COMPRESSIONCFG};
  LPNET_DVR_COMPRESSIONCFG = ^NET_DVR_COMPRESSIONCFG;

{///码流压缩参数(子结构)(扩展) 增加I帧间隔 }
type
  NET_DVR_COMPRESSION_INFO_EX = record
    byStreamType: BYTE;
    byResolution: BYTE;
    byBitrateType: BYTE;
    byPicQuality: BYTE;
    dwVideoBitrate: LongInt;
{/// 13-384K 14-448K 15-512K 16-640K 17-768K 18-896K 19-1024K 20-1280K 21-1536K 22-1792K 23-2048K }
{///最高位(31位)置成1表示是自定义码流, 0-30位表示码流值(MIN-32K MAX-8192K)。 }
    dwVideoFrameRate: LongInt;
    wIntervalFrameI: Word;
{///2006-08-11 增加单P帧的配置接口，可以改善实时流延时问题 }
    byIntervalBPFrame: BYTE;
    byRes: BYTE;
  end {NET_DVR_COMPRESSION_INFO_EX};
  LPNET_DVR_COMPRESSION_INFO_EX = ^NET_DVR_COMPRESSION_INFO_EX;

{///通道压缩参数(扩展) }
type
  NET_DVR_COMPRESSIONCFG_EX = record
    dwSize: LongInt;
    struRecordPara: NET_DVR_COMPRESSION_INFO_EX;
    struNetPara: NET_DVR_COMPRESSION_INFO_EX;
  end {NET_DVR_COMPRESSIONCFG_EX};
  LPNET_DVR_COMPRESSIONCFG_EX = ^NET_DVR_COMPRESSIONCFG_EX;


{///时间段录像参数配置(子结构) }
type
  NET_DVR_RECORDSCHED = record
    struRecordTime: NET_DVR_SCHEDTIME;
    byRecordType: BYTE;
    reservedData: Array[0..3-1] of Char;
  end {NET_DVR_RECORDSCHED};
  LPNET_DVR_RECORDSCHED = ^NET_DVR_RECORDSCHED;

{///全天录像参数配置(子结构) }
type
  NET_DVR_RECORDDAY = record
    wAllDayRecord: Word;
{= 是否全天录像 0-否 1-是 }
    byRecordType: BYTE;
{= 录象类型 0:定时录像，1:移动侦测，2:报警录像，3:动测|报警，4:动测&报警 5:命令触发, 6: 手动录像 }
    reservedData: Char;
  end {NET_DVR_RECORDDAY};
  LPNET_DVR_RECORDDAY = ^NET_DVR_RECORDDAY;

{///通道录像参数配置(9000扩展) }
type
  NET_DVR_RECORD_V30 = record
    dwSize: LongInt;
    dwRecord: LongInt;
{=是否录像 0-否 1-是 }
    struRecAllDay: Array[0..MAX_DAYS-1] of NET_DVR_RECORDDAY;
    struRecordSched: Array[0..MAX_DAYS-1,0..MAX_TIMESEGMENT_V30-1] of NET_DVR_RECORDSCHED;
    dwRecordTime: LongInt;
{= 录象延时长度 0-5秒， 1-20秒， 2-30秒， 3-1分钟， 4-2分钟， 5-5分钟， 6-10分钟 }
    dwPreRecordTime: LongInt;
{= 预录时间 0-不预录 1-5秒 2-10秒 3-15秒 4-20秒 5-25秒 6-30秒 7-0xffffffff(尽可能预录) }
    dwRecorderDuration: LongInt;
{= 录像保存的最长时间 }
    byRedundancyRec: BYTE;
{=是否冗余录像,重要数据双备份：0/1 }
    byAudioRec: BYTE;
{=录像时复合流编码时是否记录音频数据：国外有此法规 }
    byReserve: Array[0..10-1] of BYTE;
  end {NET_DVR_RECORD_V30};
  LPNET_DVR_RECORD_V30 = ^NET_DVR_RECORD_V30;

{///通道录像参数配置 }
type
  NET_DVR_RECORD = record
    dwSize: LongInt;
    dwRecord: LongInt;
{=是否录像 0-否 1-是 }
    struRecAllDay: Array[0..MAX_DAYS-1] of NET_DVR_RECORDDAY;
    struRecordSched: Array[0..MAX_DAYS-1,0..MAX_TIMESEGMENT-1]  of NET_DVR_RECORDSCHED;
    dwRecordTime: LongInt;
{= 录象时间长度 }
    dwPreRecordTime: LongInt;
{= 预录时间 0-不预录 1-5秒 2-10秒 3-15秒 4-20秒 5-25秒 6-30秒 7-0xffffffff(尽可能预录) }
  end {NET_DVR_RECORD};
  LPNET_DVR_RECORD = ^NET_DVR_RECORD;

{///云台协议表结构配置 }
type
  NET_DVR_PTZ_PROTOCOL = record
    dwType: LongInt;
{=解码器类型值，从1开始连续递增 }
    byDescribe: Array[0..DESC_LEN-1] of BYTE;
{=解码器的描述符，和8000中的一致 }
  end {NET_DVR_PTZ_PROTOCOL};

type
  NET_DVR_PTZCFG = record
    dwSize: LongInt;
    struPtz: Array[0..PTZ_PROTOCOL_NUM-1] of NET_DVR_PTZ_PROTOCOL;
{=最大200中PTZ协议 }
    dwPtzNum: LongInt;
{=有效的ptz协议数目，从0开始(即计算时加1) }
    byRes: Array[0..8-1] of BYTE;
  end {NET_DVR_PTZCFG};
  LPNET_DVR_PTZCFG = ^NET_DVR_PTZCFG;
{+//**************************云台类型(end)******************************/ }

{///通道解码器(云台)参数配置(9000扩展) }
type
  NET_DVR_DECODERCFG_V30 = record
    dwSize: LongInt;
    dwBaudRate: LongInt;
    byDataBit: BYTE;
    byStopBit: BYTE;
    byParity: BYTE;
    byFlowcontrol: BYTE;
    wDecoderType: Word;
    wDecoderAddress: Word;
{=解码器地址:0 - 255 }
    bySetPreset: Array[0..MAX_PRESET_V30-1] of BYTE;
{= 预置点是否设置,0-没有设置,1-设置 }
    bySetCruise: Array[0..MAX_CRUISE_V30-1] of BYTE;
{= 巡航是否设置: 0-没有设置,1-设置 }
    bySetTrack: Array[0..MAX_TRACK_V30-1] of BYTE;
{= 轨迹是否设置,0-没有设置,1-设置 }
  end {NET_DVR_DECODERCFG_V30};
  LPNET_DVR_DECODERCFG_V30 = ^NET_DVR_DECODERCFG_V30;

{///通道解码器(云台)参数配置 }
type
  NET_DVR_DECODERCFG = record
    dwSize: LongInt;
    dwBaudRate: LongInt;
    byDataBit: BYTE;
    byStopBit: BYTE;
    byParity: BYTE;
    byFlowcontrol: BYTE;
    wDecoderType: Word;
    wDecoderAddress: Word;
{=解码器地址:0 - 255 }
    bySetPreset: Array[0..MAX_PRESET-1] of BYTE;
{= 预置点是否设置,0-没有设置,1-设置 }
    bySetCruise: Array[0..MAX_CRUISE-1] of BYTE;
{= 巡航是否设置: 0-没有设置,1-设置 }
    bySetTrack: Array[0..MAX_TRACK-1] of BYTE;
{= 轨迹是否设置,0-没有设置,1-设置 }
  end {NET_DVR_DECODERCFG};
  LPNET_DVR_DECODERCFG = ^NET_DVR_DECODERCFG;

{///ppp参数配置(子结构) }
type
  NET_DVR_PPPCFG_V30 = record
    struRemoteIP: NET_DVR_IPADDR;
    struLocalIP: NET_DVR_IPADDR;
    sLocalIPMask: Array[0..16-1] of Char;
    sUsername: Array[0..NAME_LEN-1] of BYTE;
{= 用户名 }
    sPassword: Array[0..PASSWD_LEN-1] of BYTE;
{= 密码 }
    byPPPMode: BYTE;
    byRedial: BYTE;
    byRedialMode: BYTE;
    byDataEncrypt: BYTE;
    dwMTU: LongInt;
    sTelephoneNumber: Array[0..PHONENUMBER_LEN-1] of Char;
  end {NET_DVR_PPPCFG_V30};
  LPNET_DVR_PPPCFG_V30 = ^NET_DVR_PPPCFG_V30;

{///ppp参数配置(子结构) }
type
  NET_DVR_PPPCFG = record
    sRemoteIP: Array[0..16-1] of Char;
    sLocalIP: Array[0..16-1] of Char;
    sLocalIPMask: Array[0..16-1] of Char;
    sUsername: Array[0..NAME_LEN-1] of BYTE;
{= 用户名 }
    sPassword: Array[0..PASSWD_LEN-1] of BYTE;
{= 密码 }
    byPPPMode: BYTE;
    byRedial: BYTE;
    byRedialMode: BYTE;
    byDataEncrypt: BYTE;
    dwMTU: LongInt;
    sTelephoneNumber: Array[0..PHONENUMBER_LEN-1] of Char;
  end {NET_DVR_PPPCFG};
  LPNET_DVR_PPPCFG = ^NET_DVR_PPPCFG;

{///RS232串口参数配置(9000扩展) }
type
  NET_DVR_SINGLE_RS232 = record
    dwBaudRate: LongInt;
{=波特率(bps)，0－50，1－75，2－110，3－150，4－300，5－600，6－1200，7－2400，8－4800，9－9600，10－19200， 11－38400，12－57600，13－76800，14－115.2k; }
    byDataBit: BYTE;
{= 数据有几位 0－5位，1－6位，2－7位，3－8位 }
    byStopBit: BYTE;
{= 停止位 0－1位，1－2位 }
    byParity: BYTE;
{= 校验 0－无校验，1－奇校验，2－偶校验 }
    byFlowcontrol: BYTE;
{= 0－无，1－软流控,2-硬流控 }
    dwWorkMode: LongInt;
{= 工作模式，0－232串口用于PPP拨号，1－232串口用于参数控制，2－透明通道 }
  end {NET_DVR_SINGLE_RS232};

{///RS232串口参数配置(9000扩展) }
type
  NET_DVR_RS232CFG_V30 = record
    dwSize: LongInt;
    struRs232: NET_DVR_SINGLE_RS232;
    byRes: Array[0..84-1] of BYTE;
    struPPPConfig: NET_DVR_PPPCFG_V30;
  end {NET_DVR_RS232CFG_V30};
  LPNET_DVR_RS232CFG_V30 = ^NET_DVR_RS232CFG_V30;

{///RS232串口参数配置 }
type
  NET_DVR_RS232CFG = record
    dwSize: LongInt;
    dwBaudRate: LongInt;
    byDataBit: BYTE;
    byStopBit: BYTE;
    byParity: BYTE;
    byFlowcontrol: BYTE;
    dwWorkMode: LongInt;
    struPPPConfig: NET_DVR_PPPCFG;
  end {NET_DVR_RS232CFG};
  LPNET_DVR_RS232CFG = ^NET_DVR_RS232CFG;

{///报警输入参数配置(9000扩展) }
type
  NET_DVR_ALARMINCFG_V30 = record
    dwSize: LongInt;
    sAlarmInName: Array[0..NAME_LEN-1] of BYTE;
{= 名称 }
    byAlarmType: BYTE;
    byAlarmInHandle: BYTE;
{= 是否处理 0-不处理 1-处理 }
    byRes1: Array[0..2-1] of BYTE;
    struAlarmHandleType: NET_DVR_HANDLEEXCEPTION_V30;
{= 处理方式 }
    struAlarmTime: Array[0..MAX_DAYS-1,0..MAX_TIMESEGMENT_V30-1] of NET_DVR_SCHEDTIME;
    byRelRecordChan: Array[0..MAX_CHANNUM_V30-1] of BYTE;
    byEnablePreset: Array[0..MAX_CHANNUM_V30-1] of BYTE;
{= 是否调用预置点 0-否,1-是 }
    byPresetNo: Array[0..MAX_CHANNUM_V30-1] of BYTE;
{= 调用的云台预置点序号,一个报警输入可以调用多个通道的云台预置点, 0xff表示不调用预置点。 }
    byRes2: Array[0..192-1] of BYTE;
{=保留 }
    byEnableCruise: Array[0..MAX_CHANNUM_V30-1] of BYTE;
{= 是否调用巡航 0-否,1-是 }
    byCruiseNo: Array[0..MAX_CHANNUM_V30-1] of BYTE;
{= 巡航 }
    byEnablePtzTrack: Array[0..MAX_CHANNUM_V30-1] of BYTE;
{= 是否调用轨迹 0-否,1-是 }
    byPTZTrack: Array[0..MAX_CHANNUM_V30-1] of BYTE;
{= 调用的云台的轨迹序号 }
    byRes3: Array[0..16-1] of BYTE;
  end {NET_DVR_ALARMINCFG_V30};
  LPNET_DVR_ALARMINCFG_V30 = ^NET_DVR_ALARMINCFG_V30;

{///报警输入参数配置 }
type
  NET_DVR_ALARMINCFG = record
    dwSize: LongInt;
    sAlarmInName: Array[0..NAME_LEN-1] of BYTE;
{= 名称 }
    byAlarmType: BYTE;
    byAlarmInHandle: BYTE;
{= 是否处理 0-不处理 1-处理 }
     struAlarmHandleType: NET_DVR_HANDLEEXCEPTION;
{= 处理方式 }
    struAlarmTime: Array[0..MAX_DAYS-1,0..MAX_TIMESEGMENT-1] of NET_DVR_SCHEDTIME;
    byRelRecordChan: Array[0..MAX_CHANNUM-1] of BYTE;
    byEnablePreset: Array[0..MAX_CHANNUM-1] of BYTE;
{= 是否调用预置点 0-否,1-是 }
    byPresetNo: Array[0..MAX_CHANNUM-1] of BYTE;
{= 调用的云台预置点序号,一个报警输入可以调用多个通道的云台预置点, 0xff表示不调用预置点。 }
    byEnableCruise: Array[0..MAX_CHANNUM-1] of BYTE;
{= 是否调用巡航 0-否,1-是 }
    byCruiseNo: Array[0..MAX_CHANNUM-1] of BYTE;
{= 巡航 }
    byEnablePtzTrack: Array[0..MAX_CHANNUM-1] of BYTE;
{= 是否调用轨迹 0-否,1-是 }
    byPTZTrack: Array[0..MAX_CHANNUM-1] of BYTE;
{= 调用的云台的轨迹序号 }
  end {NET_DVR_ALARMINCFG};
  LPNET_DVR_ALARMINCFG = ^NET_DVR_ALARMINCFG;



{///上传报警信息(9000扩展) }
type
  NET_DVR_ALARMINFO_V30 = record
    dwAlarmType: LongInt;
{=0-信号量报警,1-硬盘满,2-信号丢失,3－移动侦测,4－硬盘未格式化,5-读写硬盘出错,6-遮挡报警,7-制式不匹配, 8-非法访问, 0xa-GPS定位信息(车载定制) }
    dwAlarmInputNumber: LongInt;
{=报警输入端口 }
    byAlarmOutputNumber: Array[0..MAX_ALARMOUT_V30-1] of BYTE;
{=触发的输出端口，为1表示对应输出 }
    byAlarmRelateChannel: Array[0..MAX_CHANNUM_V30-1] of BYTE;
{=触发的录像通道，为1表示对应录像, dwAlarmRelateChannel[0]对应第1个通道 }
    byChannel: Array[0..MAX_CHANNUM_V30-1] of BYTE;
{=dwAlarmType为2或3,6时，表示哪个通道，dwChannel[0]对应第1个通道 }
    byDiskNumber: Array[0..MAX_DISKNUM_V30-1] of BYTE;
{=dwAlarmType为1,4,5时,表示哪个硬盘, dwDiskNumber[0]对应第1个硬盘 }
  end {NET_DVR_ALARMINFO_V30};
  LPNET_DVR_ALARMINFO_V30 = ^NET_DVR_ALARMINFO_V30;

type
  NET_DVR_ALARMINFO = record
    dwAlarmType: LongInt;
{=0-信号量报警,1-硬盘满,2-信号丢失,3－移动侦测,4－硬盘未格式化,5-读写硬盘出错,6-遮挡报警,7-制式不匹配, 8-非法访问, 9-串口状态, 0xa-GPS定位信息(车载定制) }
    dwAlarmInputNumber: LongInt;
{=报警输入端口, 当报警类型为9时该变量表示串口状态0表示正常， -1表示错误 }
    dwAlarmOutputNumber: Array[0..MAX_ALARMOUT-1] of LongInt;
{=触发的输出端口，哪一位为1表示对应哪一个输出 }
    dwAlarmRelateChannel: Array[0..MAX_CHANNUM-1] of LongInt;
{=触发的录像通道，哪一位为1表示对应哪一路录像, dwAlarmRelateChannel[0]对应第1个通道 }
    dwChannel: Array[0..MAX_CHANNUM-1] of LongInt;
{=dwAlarmType为2或3,6时，表示哪个通道，dwChannel[0]位对应第1个通道 }
    dwDiskNumber: Array[0..MAX_DISKNUM-1] of LongInt;
{=dwAlarmType为1,4,5时,表示哪个硬盘, dwDiskNumber[0]位对应第1个硬盘 }
  end {NET_DVR_ALARMINFO};
  LPNET_DVR_ALARMINFO = ^NET_DVR_ALARMINFO;




{/////////////////////////////////////////////////////////////////////////////////////// }
{///IPC接入参数配置 }
{+// IP设备结构*/ }
type
  NET_DVR_IPDEVINFO = record
    dwEnable: LongInt;
{= 该IP设备是否启用 }
    sUserName: Array[0..NAME_LEN-1] of BYTE;
{= 用户名 }
    sPassword: Array[0..PASSWD_LEN-1] of BYTE;
{= 密码 }
    struIP: NET_DVR_IPADDR;
{= IP地址 }
    wDVRPort: Word;
{= 端口号 }
    byRes: Array[0..34-1] of BYTE;
{= 保留 }
  end {NET_DVR_IPDEVINFO};
  LPNET_DVR_IPDEVINFO = ^NET_DVR_IPDEVINFO;

{+// IP通道匹配参数*/ }
type
  NET_DVR_IPCHANINFO = record
    byEnable: BYTE;
{= 0表示9000设备的数字通道连接对应的IPC或DVS失败，该通道不在线；1表示连接成功，该通道在线； }
    byIPID: BYTE;
{= IP设备ID 取值1- MAX_IP_DEVICE }
    byChannel: BYTE;
{= 通道号 }
    byRes: Array[0..33-1] of BYTE;
{= 保留 }
  end {NET_DVR_IPCHANINFO};
  LPNET_DVR_IPCHANINFO = ^NET_DVR_IPCHANINFO;

{+// IP接入配置结构*/ }
type
  NET_DVR_IPPARACFG = record
    dwSize: LongInt;
{= 结构大小 }
    struIPDevInfo: Array[0..MAX_IP_DEVICE-1] of NET_DVR_IPDEVINFO;
{= IP设备 }
    byAnalogChanEnable: Array[0..MAX_ANALOG_CHANNUM-1] of BYTE;
{= 模拟通道是否启用，从低到高表示1-32通道，0表示无效 1有效 }
    struIPChanInfo: Array[0..MAX_IP_CHANNEL-1] of NET_DVR_IPCHANINFO;
{= IP通道 }
  end {NET_DVR_IPPARACFG};
  LPNET_DVR_IPPARACFG = ^NET_DVR_IPPARACFG;

{+// 报警输出参数*/ }
type
  NET_DVR_IPALARMOUTINFO = record
    byIPID: BYTE;
{= IP设备ID取值1- MAX_IP_DEVICE }
    byAlarmOut: BYTE;
{= 报警输出号 }
    byRes: Array[0..18-1] of BYTE;
{= 保留 }
  end {NET_DVR_IPALARMOUTINFO};
  LPNET_DVR_IPALARMOUTINFO = ^NET_DVR_IPALARMOUTINFO;

{+// IP报警输出配置结构*/ }
type
  NET_DVR_IPALARMOUTCFG = record
    dwSize: LongInt;
{= 结构大小 }
    struIPAlarmOutInfo: Array[0..MAX_IP_ALARMOUT-1] of NET_DVR_IPALARMOUTINFO;
{= IP报警输出 }
  end {NET_DVR_IPALARMOUTCFG};
  LPNET_DVR_IPALARMOUTCFG = ^NET_DVR_IPALARMOUTCFG;

{+// 报警输入参数*/ }
type
  NET_DVR_IPALARMININFO = record
    byIPID: BYTE;
{= IP设备ID取值1- MAX_IP_DEVICE }
    byAlarmIn: BYTE;
{= 报警输入号 }
    byRes: Array[0..18-1] of BYTE;
{= 保留 }
  end {NET_DVR_IPALARMININFO};
  LPNET_DVR_IPALARMININFO = ^NET_DVR_IPALARMININFO;

{+// IP报警输入配置结构*/ }
type
  NET_DVR_IPALARMINCFG = record
    dwSize: LongInt;
{= 结构大小 }
    struIPAlarmInInfo: Array[0..MAX_IP_ALARMIN-1] of NET_DVR_IPALARMININFO;
{= IP报警输入 }
  end {NET_DVR_IPALARMINCFG};
  LPNET_DVR_IPALARMINCFG = ^NET_DVR_IPALARMINCFG;

{///ipc alarm info }
type
  NET_DVR_IPALARMINFO = record
    struIPDevInfo: Array[0..MAX_IP_DEVICE-1] of NET_DVR_IPDEVINFO;
{= IP设备 }
     byAnalogChanEnable: Array[0..MAX_ANALOG_CHANNUM-1] of BYTE;
{= 模拟通道是否启用，0-未启用 1-启用 }
    struIPChanInfo: Array[0..MAX_IP_CHANNEL-1] of NET_DVR_IPCHANINFO;
{= IP通道 }
    struIPAlarmInInfo: Array[0..MAX_IP_ALARMIN-1] of NET_DVR_IPALARMININFO;
{= IP报警输入 }
    struIPAlarmOutInfo: Array[0..MAX_IP_ALARMOUT-1] of NET_DVR_IPALARMOUTINFO;
{= IP报警输出 }
  end {NET_DVR_IPALARMINFO};
  LPNET_DVR_IPALARMINFO = ^NET_DVR_IPALARMINFO;
{///本地硬盘信息配置 }
type
  NET_DVR_SINGLE_HD = record
    dwHDNo: LongInt;
{=硬盘号, 取值0~MAX_DISKNUM_V30-1 }
    dwCapacity: LongInt;
{=硬盘容量(不可设置) }
    dwFreeSpace: LongInt;
{=硬盘剩余空间(不可设置) }
    dwHdStatus: LongInt;
{=硬盘状态(不可设置) 0-正常, 1-未格式化, 2-错误, 3-SMART状态, 4-不匹配, 5-休眠 }
    byHDAttr: BYTE;
{=0-默认, 1-冗余; 2-只读 }
    byRes1: Array[0..3-1] of BYTE;
    dwHdGroup: LongInt;
{=属于哪个盘组 1-MAX_HD_GROUP }
    byRes2: Array[0..120-1] of BYTE;
  end {NET_DVR_SINGLE_HD};
  LPNET_DVR_SINGLE_HD = ^NET_DVR_SINGLE_HD;

type
  NET_DVR_HDCFG = record
    dwSize: LongInt;
    dwHDCount: LongInt;
{=硬盘数(不可设置) }
    struHDInfo: Array[0..MAX_DISKNUM_V30-1] of NET_DVR_SINGLE_HD;
  end {NET_DVR_HDCFG};
  LPNET_DVR_HDCFG = ^NET_DVR_HDCFG;

{///本地盘组信息配置 }
type
  NET_DVR_SINGLE_HDGROUP = record
    dwHDGroupNo: LongInt;
{=盘组号(不可设置) 1-MAX_HD_GROUP }
    byHDGroupChans: Array[0..64-1] of BYTE;
{=盘组对应的录像通道, 0-表示该通道不录象到该盘组，1-表示录象到该盘组 }
    byRes: Array[0..8-1] of BYTE;
  end {NET_DVR_SINGLE_HDGROUP};
  LPNET_DVR_SINGLE_HDGROUP = ^NET_DVR_SINGLE_HDGROUP;

type
  NET_DVR_HDGROUP_CFG = record
    dwSize: LongInt;
    dwHDGroupCount: LongInt;
{=盘组总数(不可设置) }
    struHDGroupAttr: Array[0..MAX_HD_GROUP-1] of NET_DVR_SINGLE_HDGROUP;
  end {NET_DVR_HDGROUP_CFG};
  LPNET_DVR_HDGROUP_CFG = ^NET_DVR_HDGROUP_CFG;


{///配置缩放参数的结构 }
type
  NET_DVR_SCALECFG = record
    dwSize: LongInt;
    dwMajorScale: LongInt;
{= 主显示 0-不缩放，1-缩放 }
    dwMinorScale: LongInt;
{= 辅显示 0-不缩放，1-缩放 }
    dwRes: Array[0..2-1] of LongInt;
  end {NET_DVR_SCALECFG};
  LPNET_DVR_SCALECFG = ^NET_DVR_SCALECFG;



{///DVR报警输出(9000扩展) }
type
  NET_DVR_ALARMOUTCFG_V30 = record
    dwSize: LongInt;
    sAlarmOutName: Array[0..NAME_LEN-1] of BYTE;
{= 名称 }
    dwAlarmOutDelay: LongInt;
{= 输出保持时间(-1为无限，手动关闭) }
{///0-5秒,1-10秒,2-30秒,3-1分钟,4-2分钟,5-5分钟,6-10分钟,7-手动 }
    struAlarmOutTime: Array[0..MAX_DAYS-1,0..MAX_TIMESEGMENT_V30-1] of NET_DVR_SCHEDTIME;
{= 报警输出激活时间段 }
    byRes: Array[0..16-1] of BYTE;
  end {NET_DVR_ALARMOUTCFG_V30};
  LPNET_DVR_ALARMOUTCFG_V30 = ^NET_DVR_ALARMOUTCFG_V30;

{///DVR报警输出 }
type
  NET_DVR_ALARMOUTCFG = record
    dwSize: LongInt;
    sAlarmOutName: Array[0..NAME_LEN-1] of BYTE;
{= 名称 }
    dwAlarmOutDelay: LongInt;
{= 输出保持时间(-1为无限，手动关闭) }
{///0-5秒,1-10秒,2-30秒,3-1分钟,4-2分钟,5-5分钟,6-10分钟,7-手动 }
    struAlarmOutTime: Array[0..MAX_DAYS-1,0..MAX_TIMESEGMENT-1] of NET_DVR_SCHEDTIME;
{= 报警输出激活时间段 }
  end {NET_DVR_ALARMOUTCFG};
  LPNET_DVR_ALARMOUTCFG = ^NET_DVR_ALARMOUTCFG;

{///DVR本地预览参数(9000扩展) }
type
  NET_DVR_PREVIEWCFG_V30 = record
    dwSize: LongInt;
    byPreviewNumber: BYTE;
    byEnableAudio: BYTE;
    wSwitchTime: Word;
    bySwitchSeq: Array[0..MAX_PREVIEW_MODE-1,0..MAX_WINDOW_V30-1] of BYTE;
    byRes: Array[0..24-1] of BYTE;
  end {NET_DVR_PREVIEWCFG_V30};
  LPNET_DVR_PREVIEWCFG_V30 = ^NET_DVR_PREVIEWCFG_V30;
{///DVR本地预览参数 }
type
  NET_DVR_PREVIEWCFG = record
    dwSize: LongInt;
    byPreviewNumber: BYTE;
    byEnableAudio: BYTE;
    wSwitchTime: Word;
    bySwitchSeq: Array[0..MAX_WINDOW-1] of BYTE;
  end {NET_DVR_PREVIEWCFG};
  LPNET_DVR_PREVIEWCFG = ^NET_DVR_PREVIEWCFG;

{///DVR视频输出 }
type
  NET_DVR_VGAPARA = record
    wResolution: Word;
{= 分辨率 }
    wFreq: Word;
{= 刷新频率 }
    dwBrightness: LongInt;
{= 亮度 }
  end {NET_DVR_VGAPARA};

{+// }
{-* MATRIX输出参数结构 }
{= }
type
  NET_DVR_MATRIXPARA_V30 = record
    wOrder: Array[0..MAX_ANALOG_CHANNUM-1] of Word;
{= 预览顺序, 0xff表示相应的窗口不预览 }
    wSwitchTime: Word;
{= 预览切换时间 }
    res: Array[0..14-1] of BYTE;
  end {NET_DVR_MATRIXPARA_V30};
  LPNET_DVR_MATRIXPARA_V30 = ^NET_DVR_MATRIXPARA_V30;

type
  NET_DVR_MATRIXPARA = record
    wDisplayLogo: Word;
{= 显示视频通道号 }
    wDisplayOsd: Word;
{= 显示时间 }
  end {NET_DVR_MATRIXPARA};

type
  NET_DVR_VOOUT = record
    byVideoFormat: BYTE;
{= 输出制式,0-PAL,1-NTSC }
    byMenuAlphaValue: BYTE;
{= 菜单与背景图象对比度 }
    wScreenSaveTime: Word;
{= 屏幕保护时间 0-从不,1-1分钟,2-2分钟,3-5分钟,4-10分钟,5-20分钟,6-30分钟 }
    wVOffset: Word;
{= 视频输出偏移 }
    wBrightness: Word;
{= 视频输出亮度 }
    byStartMode: BYTE;
{= 启动后视频输出模式(0:菜单,1:预览) }
    byEnableScaler: BYTE;
{= 是否启动缩放 (0-不启动, 1-启动) }
  end {NET_DVR_VOOUT};

{///DVR视频输出(9000扩展) }
type
  NET_DVR_VIDEOOUT_V30 = record
    dwSize: LongInt;
    struVOOut: Array[0..MAX_VIDEOOUT_V30-1] of NET_DVR_VOOUT;
    struVGAPara: Array[0..MAX_VGA_V30-1] of NET_DVR_VGAPARA;
{= VGA参数 }
    struMatrixPara: Array[0..MAX_MATRIXOUT-1] of NET_DVR_MATRIXPARA_V30;
{= MATRIX参数 }
    byRes: Array[0..16-1] of BYTE;
  end {NET_DVR_VIDEOOUT_V30};
  LPNET_DVR_VIDEOOUT_V30 = ^NET_DVR_VIDEOOUT_V30;

{///DVR视频输出 }
type
  NET_DVR_VIDEOOUT = record
    dwSize: LongInt;
    struVOOut: Array[0..MAX_VIDEOOUT-1] of NET_DVR_VOOUT;
    struVGAPara: Array[0..MAX_VGA-1] of NET_DVR_VGAPARA;
{= VGA参数 }
    struMatrixPara: NET_DVR_MATRIXPARA;
{= MATRIX参数 }
  end {NET_DVR_VIDEOOUT};
  LPNET_DVR_VIDEOOUT = ^NET_DVR_VIDEOOUT;

{///单用户参数(子结构)(9000扩展) }
type
  NET_DVR_USER_INFO_V30 = record
    sUserName: Array[0..NAME_LEN-1] of BYTE;
{= 用户名 }
    sPassword: Array[0..PASSWD_LEN-1] of BYTE;
{= 密码 }
    byLocalRight: Array[0..MAX_RIGHT-1] of BYTE;
{= 本地权限 }
{+//数组0: 本地控制云台*/ }
{+//数组1: 本地手动录象*/ }
{+//数组2: 本地回放*/ }
{+//数组3: 本地设置参数*/ }
{+//数组4: 本地查看状态、日志*/ }
{+//数组5: 本地高级操作(升级，格式化，重启，关机)*/ }
{+//数组6: 本地查看参数*/ }
{+//数组7: 本地管理模拟和IP camera*/ }
{+//数组8: 本地备份*/ }
{+//数组9: 本地关机/重启*/ }
    byRemoteRight: Array[0..MAX_RIGHT-1] of BYTE;
{= 远程权限 }
{+//数组0: 远程控制云台*/ }
{+//数组1: 远程手动录象*/ }
{+//数组2: 远程回放*/ }
{+//数组3: 远程设置参数*/ }
{+//数组4: 远程查看状态、日志*/ }
{+//数组5: 远程高级操作(升级，格式化，重启，关机)*/ }
{+//数组6: 远程发起语音对讲*/ }
{+//数组7: 远程预览*/ }
{+//数组8: 远程请求报警上传、报警输出*/ }
{+//数组9: 远程控制，本地输出*/ }
{+//数组10: 远程控制串口*/ }
{+//数组11: 远程查看参数*/ }
{+//数组12: 远程管理模拟和IP camera*/ }
{+//数组13: 远程关机/重启*/ }
    byNetPreviewRight: Array[0..MAX_CHANNUM_V30-1] of BYTE;
{= 远程可以预览的通道 0-有权限，1-无权限 }
    byLocalPlaybackRight: Array[0..MAX_CHANNUM_V30-1] of BYTE;
{= 本地可以回放的通道 0-有权限，1-无权限 }
    byNetPlaybackRight: Array[0..MAX_CHANNUM_V30-1] of BYTE;
{= 远程可以回放的通道 0-有权限，1-无权限 }
    byLocalRecordRight: Array[0..MAX_CHANNUM_V30-1] of BYTE;
{= 本地可以录像的通道 0-有权限，1-无权限 }
    byNetRecordRight: Array[0..MAX_CHANNUM_V30-1] of BYTE;
{= 远程可以录像的通道 0-有权限，1-无权限 }
    byLocalPTZRight: Array[0..MAX_CHANNUM_V30-1] of BYTE;
{= 本地可以PTZ的通道 0-有权限，1-无权限 }
    byNetPTZRight: Array[0..MAX_CHANNUM_V30-1] of BYTE;
{= 远程可以PTZ的通道 0-有权限，1-无权限 }
    byLocalBackupRight: Array[0..MAX_CHANNUM_V30-1] of BYTE;
{= 本地备份权限通道 0-有权限，1-无权限 }
    struUserIP: NET_DVR_IPADDR;
{= 用户IP地址(为0时表示允许任何地址) }
    byMACAddr: Array[0..MACADDR_LEN-1] of BYTE;
{= 物理地址 }
    byPriority: BYTE;
{= 优先级，0xff-无，0--低，1--中，2--高 }
{+// }
{-无……表示不支持优先级的设置 }
{-低……默认权限:包括本地和远程回放,本地和远程查看日志和状态,本地和远程关机/重启 }
{-中……包括本地和远程控制云台,本地和远程手动录像,本地和远程回放,语音对讲和远程预览 }
{-本地备份,本地/远程关机/重启 }
{-高……管理员 }
{= }
    byRes: Array[0..17-1] of BYTE;
  end {NET_DVR_USER_INFO_V30};
  LPNET_DVR_USER_INFO_V30 = ^NET_DVR_USER_INFO_V30;

{///单用户参数(SDK_V15扩展)(子结构) }
type
  NET_DVR_USER_INFO_EX = record
    sUserName: Array[0..NAME_LEN-1] of BYTE;
{= 用户名 }
    sPassword: Array[0..PASSWD_LEN-1] of BYTE;
{= 密码 }
    dwLocalRight: Array[0..MAX_RIGHT-1] of LongInt;
{= 权限 }
{+//数组0: 本地控制云台*/ }
{+//数组1: 本地手动录象*/ }
{+//数组2: 本地回放*/ }
{+//数组3: 本地设置参数*/ }
{+//数组4: 本地查看状态、日志*/ }
{+//数组5: 本地高级操作(升级，格式化，重启，关机)*/ }
    dwLocalPlaybackRight: LongInt;
{= 本地可以回放的通道 bit0 -- channel 1 }
    dwRemoteRight: Array[0..MAX_RIGHT-1] of LongInt;
{= 权限 }
{+//数组0: 远程控制云台*/ }
{+//数组1: 远程手动录象*/ }
{+//数组2: 远程回放*/ }
{+//数组3: 远程设置参数*/ }
{+//数组4: 远程查看状态、日志*/ }
{+//数组5: 远程高级操作(升级，格式化，重启，关机)*/ }
{+//数组6: 远程发起语音对讲*/ }
{+//数组7: 远程预览*/ }
{+//数组8: 远程请求报警上传、报警输出*/ }
{+//数组9: 远程控制，本地输出*/ }
{+//数组10: 远程控制串口*/ }
    dwNetPreviewRight: LongInt;
{= 远程可以预览的通道 bit0 -- channel 1 }
    dwNetPlaybackRight: LongInt;
{= 远程可以回放的通道 bit0 -- channel 1 }
    sUserIP: Array[0..16-1] of Char;
{= 用户IP地址(为0时表示允许任何地址) }
    byMACAddr: Array[0..MACADDR_LEN-1] of BYTE;
{= 物理地址 }
  end {NET_DVR_USER_INFO_EX};
  LPNET_DVR_USER_INFO_EX = ^NET_DVR_USER_INFO_EX;

{///单用户参数(子结构) }
type
  NET_DVR_USER_INFO = record
    sUserName: Array[0..NAME_LEN-1] of BYTE;
{= 用户名 }
    sPassword: Array[0..PASSWD_LEN-1] of BYTE;
{= 密码 }
    dwLocalRight: Array[0..MAX_RIGHT-1] of LongInt;
{= 权限 }
{+//数组0: 本地控制云台*/ }
{+//数组1: 本地手动录象*/ }
{+//数组2: 本地回放*/ }
{+//数组3: 本地设置参数*/ }
{+//数组4: 本地查看状态、日志*/ }
{+//数组5: 本地高级操作(升级，格式化，重启，关机)*/ }
    dwRemoteRight: Array[0..MAX_RIGHT-1] of LongInt;
{= 权限 }
{+//数组0: 远程控制云台*/ }
{+//数组1: 远程手动录象*/ }
{+//数组2: 远程回放*/ }
{+//数组3: 远程设置参数*/ }
{+//数组4: 远程查看状态、日志*/ }
{+//数组5: 远程高级操作(升级，格式化，重启，关机)*/ }
{+//数组6: 远程发起语音对讲*/ }
{+//数组7: 远程预览*/ }
{+//数组8: 远程请求报警上传、报警输出*/ }
{+//数组9: 远程控制，本地输出*/ }
{+//数组10: 远程控制串口*/ }
    sUserIP: Array[0..16-1] of Char;
{= 用户IP地址(为0时表示允许任何地址) }
    byMACAddr: Array[0..MACADDR_LEN-1] of BYTE;
{= 物理地址 }
  end {NET_DVR_USER_INFO};
  LPNET_DVR_USER_INFO = ^NET_DVR_USER_INFO;


{///DVR用户参数(9000扩展) }
type
  NET_DVR_USER_V30 = record
    dwSize: LongInt;
    struUser: Array[0..MAX_USERNUM_V30-1] of NET_DVR_USER_INFO_V30;
  end {NET_DVR_USER_V30};
  LPNET_DVR_USER_V30 = ^NET_DVR_USER_V30;

{///DVR用户参数(SDK_V15扩展) }
type
  NET_DVR_USER_EX = record
    dwSize: LongInt;
    struUser: Array[0..MAX_USERNUM-1] of NET_DVR_USER_INFO_EX;
  end {NET_DVR_USER_EX};
  LPNET_DVR_USER_EX = ^NET_DVR_USER_EX;

{///DVR用户参数 }
type
  NET_DVR_USER = record
    dwSize: LongInt;
    struUser: Array[0..MAX_USERNUM-1] of NET_DVR_USER_INFO;
  end {NET_DVR_USER};
  LPNET_DVR_USER = ^NET_DVR_USER;

{///DVR异常参数(9000扩展) }
type
  NET_DVR_EXCEPTION_V30 = record
    dwSize: LongInt;
    struExceptionHandleType: Array[0..MAX_EXCEPTIONNUM_V30-1] of NET_DVR_HANDLEEXCEPTION_V30;
{+//数组0-盘满,1- 硬盘出错,2-网线断,3-局域网内IP 地址冲突,4-非法访问, 5-输入/输出视频制式不匹配, 6-行车超速(车载专用)*/ }
  end {NET_DVR_EXCEPTION_V30};
  LPNET_DVR_EXCEPTION_V30 = ^NET_DVR_EXCEPTION_V30;

{///DVR异常参数 }
type
  NET_DVR_EXCEPTION = record
    dwSize: LongInt;
    struExceptionHandleType: Array[0..MAX_EXCEPTIONNUM-1] of NET_DVR_HANDLEEXCEPTION;
{+//数组0-盘满,1- 硬盘出错,2-网线断,3-局域网内IP 地址冲突,4-非法访问, 5-输入/输出视频制式不匹配, 6-行车超速(车载专用)*/ }
  end {NET_DVR_EXCEPTION};
  LPNET_DVR_EXCEPTION = ^NET_DVR_EXCEPTION;

{///通道状态(9000扩展) }
type
  NET_DVR_CHANNELSTATE_V30 = record
    byRecordStatic: BYTE;
    bySignalStatic: BYTE;
    byHardwareStatic: BYTE;
    byRes1: BYTE;
    dwBitRate: LongInt;
    dwLinkNum: LongInt;
    struClientIP: Array[0..MAX_LINK-1] of NET_DVR_IPADDR;
    dwIPLinkNum: LongInt;
    byRes: Array[0..12-1] of BYTE;
  end {NET_DVR_CHANNELSTATE_V30};
  LPNET_DVR_CHANNELSTATE_V30 = ^NET_DVR_CHANNELSTATE_V30;

{///通道状态 }
type
  NET_DVR_CHANNELSTATE = record
    byRecordStatic: BYTE;
    bySignalStatic: BYTE;
    byHardwareStatic: BYTE;
    reservedData: Char;
    dwBitRate: LongInt;
    dwLinkNum: LongInt;
    dwClientIP: Array[0..MAX_LINK-1] of LongInt;
  end {NET_DVR_CHANNELSTATE};
  LPNET_DVR_CHANNELSTATE = ^NET_DVR_CHANNELSTATE;

{///硬盘状态 }
type
  NET_DVR_DISKSTATE = record
    dwVolume: LongInt;
    dwFreeSpace: LongInt;
    dwHardDiskStatic: LongInt;
  end {NET_DVR_DISKSTATE};
  LPNET_DVR_DISKSTATE = ^NET_DVR_DISKSTATE;

{///DVR工作状态(9000扩展) }
type
  NET_DVR_WORKSTATE_V30 = record
    dwDeviceStatic: LongInt;
    struHardDiskStatic: Array[0..MAX_DISKNUM_V30-1] of NET_DVR_DISKSTATE;
    struChanStatic: Array[0..MAX_CHANNUM_V30-1] of NET_DVR_CHANNELSTATE_V30;
    byAlarmInStatic: Array[0..MAX_ALARMIN_V30-1] of BYTE;
    byAlarmOutStatic: Array[0..MAX_ALARMOUT_V30-1] of BYTE;
    dwLocalDisplay: LongInt;
    byAudioChanStatus: Array[0..MAX_AUDIO_V30-1] of BYTE;
    byRes: Array[0..10-1] of BYTE;
  end {NET_DVR_WORKSTATE_V30};
  LPNET_DVR_WORKSTATE_V30 = ^NET_DVR_WORKSTATE_V30;

{///DVR工作状态 }
type
  NET_DVR_WORKSTATE = record
    dwDeviceStatic: LongInt;
    struHardDiskStatic: Array[0..MAX_DISKNUM-1] of NET_DVR_DISKSTATE;
    struChanStatic: Array[0..MAX_CHANNUM-1] of NET_DVR_CHANNELSTATE;
    byAlarmInStatic: Array[0..MAX_ALARMIN-1] of BYTE;
    byAlarmOutStatic: Array[0..MAX_ALARMOUT-1] of BYTE;
    dwLocalDisplay: LongInt;
  end {NET_DVR_WORKSTATE};
  LPNET_DVR_WORKSTATE = ^NET_DVR_WORKSTATE;

{+//***********************DVR日志 begin***************************/ }

{+// 报警*/ }
{///主类型 }
const
  MAJOR_ALARM = $1;
{///次类型 }
const
  MINOR_ALARM_IN = $1; {/* 报警输入*/}
const
  MINOR_ALARM_OUT = $2; {/* 报警输出*/}
const
  MINOR_MOTDET_START = $3; {/* 移动侦测报警开始*/}
const
  MINOR_MOTDET_STOP = $4; {/* 移动侦测报警结束*/}
const
  MINOR_HIDE_ALARM_START = $5; {/* 遮挡报警开始*/}
const
  MINOR_HIDE_ALARM_STOP = $6; {/* 遮挡报警结束*/}

{+// 异常*/ }
{///主类型 }
const
  MAJOR_EXCEPTION = $2;
{///次类型 }
const
  MINOR_VI_LOST = $21; {/* 视频信号丢失*/}
const
  MINOR_ILLEGAL_ACCESS = $22; {/* 非法访问*/}
const
  MINOR_HD_FULL = $23; {/* 硬盘满*/}
const
  MINOR_HD_ERROR = $24; {/* 硬盘错误*/}
const
  MINOR_DCD_LOST = $25; {/* MODEM 掉线(保留不使用)*/}
const
  MINOR_IP_CONFLICT = $26; {/* IP地址冲突*/}
const
  MINOR_NET_BROKEN = $27; {/* 网络断开*/}
const
  MINOR_REC_ERROR = $28; {/* 录像出错*/}
const
  MINOR_IPC_NO_LINK = $29; {/* IPC连接异常*/}
const
  MINOR_VI_EXCEPTION = $2a; {/* 视频输入异常(只针对模拟通道)*/}


{+// 操作*/ }
{///主类型 }
const
  MAJOR_OPERATION = $3;
{///次类型 }
const
  MINOR_START_DVR = $41; {/* 开机*/}
const
  MINOR_STOP_DVR = $42; {/* 关机*/}
const
  MINOR_STOP_ABNORMAL = $43; {/* 异常关机*/}
const
  MINOR_REBOOT_DVR = $44; {/*本地重启设备*/}

const
  MINOR_LOCAL_LOGIN = $50; {/* 本地登陆*/}
const
  MINOR_LOCAL_LOGOUT = $51; {/* 本地注销登陆*/}
const
  MINOR_LOCAL_CFG_PARM = $52; {/* 本地配置参数*/}
const
  MINOR_LOCAL_PLAYBYFILE = $53; {/* 本地按文件回放或下载*/}
const
  MINOR_LOCAL_PLAYBYTIME = $54; {/* 本地按时间回放或下载*/}
const
  MINOR_LOCAL_START_REC = $55; {/* 本地开始录像*/}
const
  MINOR_LOCAL_STOP_REC = $56; {/* 本地停止录像*/}
const
  MINOR_LOCAL_PTZCTRL = $57; {/* 本地云台控制*/}
const
  MINOR_LOCAL_PREVIEW = $58; {/* 本地预览 (保留不使用)*/}
const
  MINOR_LOCAL_MODIFY_TIME = $59; {/* 本地修改时间(保留不使用)*/}
const
  MINOR_LOCAL_UPGRADE = $5a; {/* 本地升级*/}
const
  MINOR_LOCAL_RECFILE_OUTPUT = $5b; {/* 本地备份录象文件*/}
const
  MINOR_LOCAL_FORMAT_HDD = $5c; {/* 本地初始化硬盘*/}
const
  MINOR_LOCAL_CFGFILE_OUTPUT = $5d; {/* 导出本地配置文件*/}
const
  MINOR_LOCAL_CFGFILE_INPUT = $5e; {/* 导入本地配置文件*/}
const
  MINOR_LOCAL_COPYFILE = $5; {/* 本地备份文件*/}
const
  MINOR_LOCAL_LOCKFILE = $60; {/* 本地锁定录像文件*/}
const
  MINOR_LOCAL_UNLOCKFILE = $61; {/* 本地解锁录像文件*/}
const
  MINOR_LOCAL_DVR_ALARM = $62; {/* 本地手动清除和触发报警*/}
const
  MINOR_IPC_ADD = $63; {/* 本地添加IPC*/}
const
  MINOR_IPC_DEL = $64; {/* 本地删除IPC*/}
const
  MINOR_IPC_SET = $65; {/* 本地设置IPC*/}
const
  MINOR_LOCAL_START_BACKUP = $66; {/* 本地开始备份*/}
const
  MINOR_LOCAL_STOP_BACKUP = $67; {/* 本地停止备份*/}
const
  MINOR_LOCAL_COPYFILE_START_TIME = $68; {/* 本地备份开始时间*/}
const
  MINOR_LOCAL_COPYFILE_END_TIME = $69; {/* 本地备份结束时间*/}


const
  MINOR_REMOTE_LOGIN = $70; {/* 远程登录*/}
const
  MINOR_REMOTE_LOGOUT = $71; {/* 远程注销登陆*/}
const
  MINOR_REMOTE_START_REC = $72; {/* 远程开始录像*/}
const
  MINOR_REMOTE_STOP_REC = $73; {/* 远程停止录像*/}
const
  MINOR_START_TRANS_CHAN = $74; {/* 开始透明传输*/}
const
  MINOR_STOP_TRANS_CHAN = $75; {/* 停止透明传输*/}
const
  MINOR_REMOTE_GET_PARM = $76; {/* 远程获取参数*/}
const
  MINOR_REMOTE_CFG_PARM = $77; {/* 远程配置参数*/}
const
  MINOR_REMOTE_GET_STATUS = $78; {/* 远程获取状态*/}
const
  MINOR_REMOTE_ARM = $79; {/* 远程布防*/}
const
  MINOR_REMOTE_DISARM = $7a; {/* 远程撤防*/}
const
  MINOR_REMOTE_REBOOT = $7b; {/* 远程重启*/}
const
  MINOR_START_VT = $7c; {/* 开始语音对讲*/}
const
  MINOR_STOP_VT = $7d; {/* 停止语音对讲*/}
const
  MINOR_REMOTE_UPGRADE = $7e; {/* 远程升级*/}
const
  MINOR_REMOTE_PLAYBYFILE = $7; {/* 远程按文件回放*/}
const
  MINOR_REMOTE_PLAYBYTIME = $80; {/* 远程按时间回放*/}
const
  MINOR_REMOTE_PTZCTRL = $81; {/* 远程云台控制*/}
const
  MINOR_REMOTE_FORMAT_HDD = $82; {/* 远程格式化硬盘*/}
const
  MINOR_REMOTE_STOP = $83; {/* 远程关机*/}
const
  MINOR_REMOTE_LOCKFILE = $84; {/* 远程锁定文件*/}
const
  MINOR_REMOTE_UNLOCKFILE = $85; {/* 远程解锁文件*/}
const
  MINOR_REMOTE_CFGFILE_OUTPUT = $86; {/* 远程导出配置文件*/}
const
  MINOR_REMOTE_CFGFILE_INTPUT = $87; {/* 远程导入配置文件*/}
const
  MINOR_REMOTE_RECFILE_OUTPUT = $88; {/* 远程导出录象文件*/}
const
  MINOR_REMOTE_DVR_ALARM = $89; {/* 远程手动清除和触发报警*/}
const
  MINOR_REMOTE_IPC_ADD = $8a; {/* 远程添加IPC*/}
const
  MINOR_REMOTE_IPC_DEL = $8b; {/* 远程删除IPC*/}
const
  MINOR_REMOTE_IPC_SET = $8c; {/* 远程设置IPC*/}


{+//日志附加信息*/ }
{///主类型 }
const
  MAJOR_INFORMATION = $4; {/*附加信息*/}
{///次类型 }
const
  MINOR_HDD_INFO = $a1; {/*硬盘信息*/}
const
  MINOR_SMART_INFO = $a2; {/*SMART信息*/}
const
  MINOR_REC_START = $a3; {/*开始录像*/}
const
  MINOR_REC_STOP = $a4; {/*停止录像*/}
const
  MINOR_REC_OVERDUE = $a5; {/*过期录像删除*/}

{///当日志的主类型为MAJOR_OPERATION=03，次类型为MINOR_LOCAL_CFG_PARM=0x52或者MINOR_REMOTE_GET_PARM=0x76或者MINOR_REMOTE_CFG_PARM=0x77时，dwParaType:参数类型有效，其含义如下： }
const
  PARA_VIDEOOUT = $1;
const
  PARA_IMAGE = $2;
const
  PARA_ENCODE = $4;
const
  PARA_NETWORK = $8;
const
  PARA_ALARM = $10;
const
  PARA_EXCEPTION = $20;
const
  PARA_DECODER = $40; {/*解码器*/}
const
  PARA_RS232 = $80;
const
  PARA_PREVIEW = $100;
const
  PARA_SECURITY = $200;
const
  PARA_DATETIME = $400;
const
  PARA_FRAMETYPE = $800; {/*帧格式*/}
 type LPByte = ^Byte;
{///日志信息(9000扩展) }
type
  NET_DVR_LOG_V30 = record
    strLogTime: NET_DVR_TIME;
    dwMajorType: LongInt;
    dwMinorType: LongInt;
    sPanelUser: Array[0..MAX_NAMELEN-1] of BYTE;
    sNetUser: Array[0..MAX_NAMELEN-1] of BYTE;
    struRemoteHostAddr: NET_DVR_IPADDR;
    dwParaType: LongInt;
    dwChannel: LongInt;
    dwDiskNumber: LongInt;
    dwAlarmInPort: LongInt;
    dwAlarmOutPort: LongInt;
    dwInfoLen: LongInt;
    sInfo: Array[0..LOG_INFO_LEN-1] of Char;
  end {NET_DVR_LOG_V30};
  LPNET_DVR_LOG_V30 = ^NET_DVR_LOG_V30;

{///日志信息 }
type
  NET_DVR_LOG = record
    strLogTime: NET_DVR_TIME;
    dwMajorType: LongInt;
    dwMinorType: LongInt;
    sPanelUser: Array[0..MAX_NAMELEN-1] of BYTE;
    sNetUser: Array[0..MAX_NAMELEN-1] of BYTE;
    sRemoteHostAddr: Array[0..16-1] of Char;
    dwParaType: LongInt;
    dwChannel: LongInt;
    dwDiskNumber: LongInt;
    dwAlarmInPort: LongInt;
    dwAlarmOutPort: LongInt;
  end {NET_DVR_LOG};
  LPNET_DVR_LOG = ^NET_DVR_LOG;

{+//***********************DVR日志 end***************************/ }


{///报警输出状态(9000扩展) }
type
  NET_DVR_ALARMOUTSTATUS_V30 = record
    Output: Array[0..MAX_ALARMOUT_V30-1] of BYTE;
  end {NET_DVR_ALARMOUTSTATUS_V30};
  LPNET_DVR_ALARMOUTSTATUS_V30 = ^NET_DVR_ALARMOUTSTATUS_V30;

{///报警输出状态 }
type
  NET_DVR_ALARMOUTSTATUS = record
    Output: Array[0..MAX_ALARMOUT-1] of BYTE;
  end {NET_DVR_ALARMOUTSTATUS};
  LPNET_DVR_ALARMOUTSTATUS = ^NET_DVR_ALARMOUTSTATUS;

{///交易信息 }
type
  NET_DVR_TRADEINFO = record
    m_Year: Word;
    m_Month: Word;
    m_Day: Word;
    m_Hour: Word;
    m_Minute: Word;
    m_Second: Word;
    DeviceName: Array[0..24-1] of BYTE;
    dwChannelNumer: LongInt;
    CardNumber: Array[0..32-1] of BYTE;
    cTradeType: Array[0..12-1] of Char;
    dwCash: LongInt;
  end {NET_DVR_TRADEINFO};
  LPNET_DVR_TRADEINFO = ^NET_DVR_TRADEINFO;


type
  NET_DVR_PLATE_INFO = record
  byPlateType:BYTE;
  byColor:BYTE;
  byBright:BYTE ;
  byLicenseLen:BYTE;
  byEntireBelieve:BYTE;
  byRes: array[0..34]of BYTE;
  struPlateRect:NET_VCA_RECT;
  sLicense:array [0..MAX_LICENSE_LEN-1] of char;
  byBelieve:array [0..MAX_LICENSE_LEN-1]of BYTE;
  end; 

  LPNET_DVR_PLATE_INFO = ^NET_DVR_PLATE_INFO;


  type NET_DVR_VEHICLE_INFO = record

	dwIndex:longword ;					//车辆序号
	byVehicleType:BYTE ;		//车辆类型，0 表示其它车型，1 表示小型车，2 表示大型车
	byColorDepth:BYTE ;		//车身颜色深浅，0-深色，1-浅色
	byColor:BYTE ;					//车身颜色，0-其他色，1-白色，2-银色，3-灰色，4-黑色，5-红色，6-深蓝，7-蓝色，8-黄色，9-绿色，10-棕色，11-粉色；12-紫色；
	byRes1:BYTE ;				//保留
	wSpeed:WORD ;					//车辆速度，单位km/h
	wLength:WORD ;					//车身长度
	byIllegalType:BYTE ;           //0-正常;1-低速2-超速3-逆行；4-闯红灯
	byRes:array [0..34] of BYTE ;					//保留
  end;
LPNET_DVR_VEHICLE_INFO =^NET_DVR_VEHICLE_INFO;


{///智能高清网络摄像机报警上传 }
type
  NET_DVR_PLATE_RESULT = record
  dwSize:Longword ;
  byResultType: BYTE;
  byChanIndex: BYTE;
  wAlarmRecordID:WORD;
  dwRelativeTime:Longword ;
  byAbsTime:array[0..31] of BYTE;
  dwPicLen:Longword;
  dwPicPlateLen:Longword;
  dwVideoLen:Longword;
  byTrafficLight:BYTE;
  byPicNum:BYTE;
  byDriveChan:BYTE ;
  byVehicleType:BYTE ;
  byRes2:array[0..31] of BYTE;
  //byCameraID:array[0..3] of BYTE;
 // byRes3:array[0..27] of BYTE;
  struPlateInfo:NET_DVR_PLATE_INFO;
  struVehicleInfo:NET_DVR_VEHICLE_INFO;
  pBuffer1:lpbyte;
  pBuffer2:lpbyte ;

  end;
  LPNET_DVR_PLATE_RESULT = ^NET_DVR_PLATE_RESULT;



  type
  NET_DVR_MANUALSNAP1 = record
     byRes:array[0..23] of BYTE;
  end;
  LPNET_DVR_MANUALSNAP1 = ^NET_DVR_MANUALSNAP1;


  type
  NET_DVR_SNAPCFG = record
      dwSize:Longword      ;
      byRelatedDriveWay:BYTE;
      bySnapTimes:BYTE;
      wSnapWaitTime:WORD;
      wIntervalTime: array [0..MAX_INTERVAL_NUM-1]of WORD;
      byRes2:array[0..23] of BYTE;
  end;
  LPNET_DVR_SNAPCFG = ^NET_DVR_SNAPCFG;






{///ATM专用 }
{+//***************************ATM(begin)***************************/ }
const
  NCR = 0;
const
  DIEBOLD = 1;
const
  WINCOR_NIXDORF = 2;
const
  SIEMENS = 3;
const
  OLIVETTI = 4;
const
  FUJITSU = 5;
const
  HITACHI = 6;
const
  SMI = 7;
const
  IBM = 8;
const
  BULL = 9;
const
  YiHua = 10;
const
  LiDe = 11;
const
  GDYT = 12;
const
  Mini_Banl = 13;
const
  GuangLi = 14;
const
  DongXin = 15;
const
  ChenTong = 16;
const
  NanTian = 17;
const
  XiaoXing = 18;
const
  GZYY = 19;
const
  QHTLT = 20;
const
  DRS918 = 21;
const
  KALATEL = 22;
const
  NCR_2 = 23;
const
  NXS = 24;


{+//帧格式*/ }
type
  NET_DVR_FRAMETYPECODE = record
    code: Array[0..12-1] of BYTE;
{= 代码 }
  end {NET_DVR_FRAMETYPECODE};

{///ATM参数(9000扩展) }
type
  NET_DVR_FRAMEFORMAT_V30 = record
    dwSize: LongInt;
    struATMIP: NET_DVR_IPADDR;
{= ATM IP地址 }
    dwATMType: LongInt;
{= ATM类型 }
    dwInputMode: LongInt;
{= 输入方式 0-网络侦听 1-网络接收 2-串口直接输入 3-串口ATM命令输入 }
    dwFrameSignBeginPos: LongInt;
{= 报文标志位的起始位置 }
    dwFrameSignLength: LongInt;
{= 报文标志位的长度 }
    byFrameSignContent: Array[0..12-1] of BYTE;
{= 报文标志位的内容 }
    dwCardLengthInfoBeginPos: LongInt;
{= 卡号长度信息的起始位置 }
    dwCardLengthInfoLength: LongInt;
{= 卡号长度信息的长度 }
    dwCardNumberInfoBeginPos: LongInt;
{= 卡号信息的起始位置 }
    dwCardNumberInfoLength: LongInt;
{= 卡号信息的长度 }
    dwBusinessTypeBeginPos: LongInt;
{= 交易类型的起始位置 }
    dwBusinessTypeLength: LongInt;
{= 交易类型的长度 }
    frameTypeCode: Array[0..10-1] of NET_DVR_FRAMETYPECODE;
{= 类型 }
    wATMPort: Word;
{= 卡号捕捉端口号(网络协议方式) }
    wProtocolType: Word;
{= 网络协议类型 }
    byRes: Array[0..24-1] of BYTE;
  end {NET_DVR_FRAMEFORMAT_V30};
  LPNET_DVR_FRAMEFORMAT_V30 = ^NET_DVR_FRAMEFORMAT_V30;

{///ATM参数 }
type
  NET_DVR_FRAMEFORMAT = record
    dwSize: LongInt;
    sATMIP: Array[0..16-1] of Char;
{= ATM IP地址 }
    dwATMType: LongInt;
{= ATM类型 }
    dwInputMode: LongInt;
{= 输入方式 0-网络侦听 1-网络接收 2-串口直接输入 3-串口ATM命令输入 }
    dwFrameSignBeginPos: LongInt;
{= 报文标志位的起始位置 }
    dwFrameSignLength: LongInt;
{= 报文标志位的长度 }
    byFrameSignContent: Array[0..12-1] of BYTE;
{= 报文标志位的内容 }
    dwCardLengthInfoBeginPos: LongInt;
{= 卡号长度信息的起始位置 }
    dwCardLengthInfoLength: LongInt;
{= 卡号长度信息的长度 }
    dwCardNumberInfoBeginPos: LongInt;
{= 卡号信息的起始位置 }
    dwCardNumberInfoLength: LongInt;
{= 卡号信息的长度 }
    dwBusinessTypeBeginPos: LongInt;
{= 交易类型的起始位置 }
    dwBusinessTypeLength: LongInt;
{= 交易类型的长度 }
    frameTypeCode: Array[0..10-1] of NET_DVR_FRAMETYPECODE;
{= 类型 }
  end {NET_DVR_FRAMEFORMAT};
  LPNET_DVR_FRAMEFORMAT = ^NET_DVR_FRAMEFORMAT;


{+//****************************DS-6001D/F(begin)***************************/ }
{///DS-6001D Decoder }
type
  NET_DVR_DECODERINFO = record
    byEncoderIP: Array[0..16-1] of BYTE;
    byEncoderUser: Array[0..16-1] of BYTE;
    byEncoderPasswd: Array[0..16-1] of BYTE;
    bySendMode: BYTE;
    byEncoderChannel: BYTE;
    wEncoderPort: Word;
    reservedData: Array[0..4-1] of BYTE;
  end {NET_DVR_DECODERINFO};
  LPNET_DVR_DECODERINFO = ^NET_DVR_DECODERINFO;

type
  NET_DVR_DECODERSTATE = record
    byEncoderIP: Array[0..16-1] of BYTE;
    byEncoderUser: Array[0..16-1] of BYTE;
    byEncoderPasswd: Array[0..16-1] of BYTE;
    byEncoderChannel: BYTE;
    bySendMode: BYTE;
    wEncoderPort: Word;
    dwConnectState: LongInt;
    reservedData: Array[0..4-1] of BYTE;
  end {NET_DVR_DECODERSTATE};
  LPNET_DVR_DECODERSTATE = ^NET_DVR_DECODERSTATE;

{+//解码设备控制码定义*/ }
const
  NET_DEC_STARTDEC = 1;
const
  NET_DEC_STOPDEC = 2;
const
  NET_DEC_STOPCYCLE = 3;
const
  NET_DEC_CONTINUECYCLE = 4;
{+//连接的通道配置*/ }
type
  NET_DVR_DECCHANINFO = record
    sDVRIP: Array[0..16-1] of Char;
{= DVR IP地址 }
    wDVRPort: Word;
{= 端口号 }
    sUserName: Array[0..NAME_LEN-1] of BYTE;
{= 用户名 }
    sPassword: Array[0..PASSWD_LEN-1] of BYTE;
{= 密码 }
    byChannel: BYTE;
{= 通道号 }
    byLinkMode: BYTE;
{= 连接模式 }
    byLinkType: BYTE;
{= 连接类型 0－主码流 1－子码流 }
  end {NET_DVR_DECCHANINFO};
  LPNET_DVR_DECCHANINFO = ^NET_DVR_DECCHANINFO;

{+//每个解码通道的配置*/ }
type
  NET_DVR_DECINFO = record
    byPoolChans: BYTE;
{=每路解码通道上的循环通道数量, 最多4通道 0表示没有解码 }
    struchanConInfo: Array[0..MAX_DECPOOLNUM-1] of NET_DVR_DECCHANINFO;
    byEnablePoll: BYTE;
{=是否轮巡 0-否 1-是 }
    byPoolTime: BYTE;
{=轮巡时间 0-保留 1-10秒 2-15秒 3-20秒 4-30秒 5-45秒 6-1分钟 7-2分钟 8-5分钟 }
  end {NET_DVR_DECINFO};
  LPNET_DVR_DECINFO = ^NET_DVR_DECINFO;

{+//整个设备解码配置*/ }
type
  NET_DVR_DECCFG = record
    dwSize: LongInt;
    dwDecChanNum: LongInt;
{=解码通道的数量 }
    struDecInfo: Array[0..MAX_DECNUM-1] of NET_DVR_DECINFO;
  end {NET_DVR_DECCFG};
  LPNET_DVR_DECCFG = ^NET_DVR_DECCFG;

{///2005-08-01 }
{+// 解码设备透明通道设置*/ }
type
  NET_DVR_PORTINFO = record
    dwEnableTransPort: LongInt;
{= 是否启动透明通道 0－不启用 1－启用 }
    sDecoderIP: Array[0..16-1] of Char;
{= DVR IP地址 }
    wDecoderPort: Word;
{= 端口号 }
    wDVRTransPort: Word;
{= 配置前端DVR是从485/232输出，1表示232串口,2表示485串口 }
    cReserve: Array[0..4-1] of Char;
  end {NET_DVR_PORTINFO};
  LPNET_DVR_PORTINFO = ^NET_DVR_PORTINFO;

type
  NET_DVR_PORTCFG = record
    dwSize: LongInt;
    struTransPortInfo: Array[0..MAX_TRANSPARENTNUM-1] of NET_DVR_PORTINFO;
{= 数组0表示232 数组1表示485 }
  end {NET_DVR_PORTCFG};
  LPNET_DVR_PORTCFG = ^NET_DVR_PORTCFG;

{+// 控制网络文件回放*/ }
type
  Tbytime = record
    dwChannel: Longword;
    sUserName: Array[0..NAME_LEN-1] of Byte;
    sPassword: Array[0..PASSWD_LEN-1] of Byte;
    struStartTime: NET_DVR_TIME;
    struStopTime: NET_DVR_TIME;
  end;

  Tmode_size = record
    case Integer of
    0:(byFile: Array[0..99] of Byte);
    1:(byTime: Tbytime);
  end;

  NET_DVR_PLAYREMOTEFILE = record
    dwSize: Longword;
    sDecoderIP: Array[0..16-1] of Char;
    wDecoderPort: Word;  //Port no.
    wLoadMode: Word;     //回放下载模式 1－按名字 2－按时间
    mode_size: Tmode_size;
  end;
  LPNET_DVR_PLAYREMOTEFILE = ^NET_DVR_PLAYREMOTEFILE;


{+//当前设备解码连接状态*/ }
type
  TuserInfo = record
    sUserName: Array[0..NAME_LEN-1] of Byte;  //请求视频用户名
    sPassword: Array[0..PASSWD_LEN-1] of Byte;//密码
    cReserve: Array[0..51] of Char;
  end;
  TfileInfo = record
    fileName: Array[0..99] of Byte;
  end;
  TtimeInfo = record
    dwChannel: Longword;
    sUserName: Array[0..NAME_LEN-1] of Byte;   //请求视频用户名
    sPassword: Array[0..PASSWD_LEN-1] of Byte; //密码
    struStartTime: NET_DVR_TIME;               //按时间回放的开始时间
    struStopTime: NET_DVR_TIME;                //按时间回放的结束时间
  end;
  TobjectInfo = record
    case Integer of
    0: (userInfo: TuserInfo);
    1: (fileInfo: TfileInfo);
    2: (timeInfo: TtimeInfo);
  end;

  NET_DVR_DECCHANSTATUS = record
     dwWorkType: Longword;//工作方式：1：轮巡、2：动态连接解码、3：文件回放下载 4：按时间回放下载
    sDVRIP: Array[0..16-1] of Char;//连接的设备ip
    wDVRPort: Word;                //连接端口号
    byChannel: Byte;               //通道号
    byLinkMode: Byte;              //连接模式
    dwLinkType: Longword;           //连接类型 0－主码流 1－子码流
    objectInfo: TobjectInfo;
  end;
  LPNET_DVR_DECCHANSTATUS = ^NET_DVR_DECCHANSTATUS;

type
  NET_DVR_DECSTATUS = record
    dwSize: LongInt;
    struDecState: Array[0..MAX_DECNUM-1] of NET_DVR_DECCHANSTATUS;
  end {NET_DVR_DECSTATUS};
  LPNET_DVR_DECSTATUS = ^NET_DVR_DECSTATUS;
{+//****************************DS-6001D/F(end)***************************/ }

{///单字符参数(子结构) }
type
  NET_DVR_SHOWSTRINGINFO = record
    wShowString: Word;
    wStringSize: Word;
{= 该行字符的长度，不能大于44个字符 }
    wShowStringTopLeftX: Word;
{= 字符显示位置的x坐标 }
    wShowStringTopLeftY: Word;
{= 字符名称显示位置的y坐标 }
    sString: Array[0..44-1] of Char;
{= 要显示的字符内容 }
  end {NET_DVR_SHOWSTRINGINFO};
  LPNET_DVR_SHOWSTRINGINFO = ^NET_DVR_SHOWSTRINGINFO;

{///叠加字符(9000扩展) }
type
  NET_DVR_SHOWSTRING_V30 = record
    dwSize: LongInt;
    struStringInfo: Array[0..MAX_STRINGNUM_V30-1] of NET_DVR_SHOWSTRINGINFO;
{= 要显示的字符内容 }
  end {NET_DVR_SHOWSTRING_V30};
  LPNET_DVR_SHOWSTRING_V30 = ^NET_DVR_SHOWSTRING_V30;

{///叠加字符扩展(8条字符) }
type
  NET_DVR_SHOWSTRING_EX = record
    dwSize: LongInt;
    struStringInfo: Array[0..MAX_STRINGNUM_EX-1] of NET_DVR_SHOWSTRINGINFO;
{= 要显示的字符内容 }
  end {NET_DVR_SHOWSTRING_EX};
  LPNET_DVR_SHOWSTRING_EX = ^NET_DVR_SHOWSTRING_EX;

{///叠加字符 }
type
  NET_DVR_SHOWSTRING = record
    dwSize: LongInt;
    struStringInfo: Array[0..MAX_STRINGNUM-1] of NET_DVR_SHOWSTRINGINFO;
{= 要显示的字符内容 }
  end {NET_DVR_SHOWSTRING};
  LPNET_DVR_SHOWSTRING = ^NET_DVR_SHOWSTRING;

{+//***************************DS9000新增结构(begin)******************************/ }

{-EMAIL参数结构 }
type
  TstruSender = record
    sName: Array[0..NAME_LEN-1] of Byte;            //发件人姓名
    sAddress: Array[0..MAX_DOMAIN_NAME-1] of Byte;  //发件人地址
  end;
  TstruReceiver = record
    sName: Array[0..NAME_LEN-1] of BYTE;           //收件人姓名
    sAddress: Array[0..MAX_DOMAIN_NAME-1] of BYTE; //收件人地址
  end;

  NET_DVR_EMAILCFG_V30 = record
    dwSize: Longword;
    sAccount: Array[0..NAME_LEN-1] of BYTE;     //账号
    sPassword: Array[0..PASSWD_LEN-1] of BYTE;  //密码
    struSender: TstruSender;
    sSmtpServer: Array[0..MAX_DOMAIN_NAME-1] of Byte; //smpt服务器
    sPop3Server: Array[0..MAX_DOMAIN_NAME-1] of byte; //POP3服务器
    struReceiver: Array[0..3-1] of TstruReceiver;
    byAttachment: Byte;					    //是否带附件
	  bySmtpServerVerify: Byte;				//发送服务器要求身份验证
    byMailInterval: Byte;     //mail interval
    res: Array [0..77-1] of Byte;
  end;
  LPNET_DVR_EMAILCFG_V30 = ^NET_DVR_EMAILCFG_V30;

{+// }
{-DVR实现巡航数据结构 }
{= }
type
  NET_DVR_CRUISE_PARA = record
    dwSize: LongInt;
    byPresetNo: Array[0..CRUISE_MAX_PRESET_NUMS-1] of BYTE;
{= 预置点号 }
    byCruiseSpeed: Array[0..CRUISE_MAX_PRESET_NUMS-1] of BYTE;
{= 巡航速度 }
    wDwellTime: Array[0..CRUISE_MAX_PRESET_NUMS-1] of Word;
{= 停留时间 }
    byEnableThisCruise: BYTE;
{= 是否启用 }
    res: Array[0..15-1] of BYTE;
  end {NET_DVR_CRUISE_PARA};
  LPNET_DVR_CRUISE_PARA = ^NET_DVR_CRUISE_PARA;
{+//***************************DS9000新增结构(end)******************************/ }


{///时间点 }
type
  NET_DVR_TIMEPOINT = record
    dwMonth: LongInt;
    dwWeekNo: LongInt;
    dwWeekDate: LongInt;
    dwHour: LongInt;
    dwMin: LongInt;
  end {NET_DVR_TIMEPOINT};

{///夏令时参数 }
type
  NET_DVR_ZONEANDDST = record
    dwSize: LongInt;
    byRes1: Array[0..16-1] of BYTE;
    dwEnableDST: LongInt;
    byDSTBias: BYTE;
    byRes2: Array[0..3-1] of BYTE;
    struBeginPoint: NET_DVR_TIMEPOINT;
    struEndPoint: NET_DVR_TIMEPOINT;
  end {NET_DVR_ZONEANDDST};
  LPNET_DVR_ZONEANDDST = ^NET_DVR_ZONEANDDST;



{///图片质量 }
type
  NET_DVR_JPEGPARA = record
{+//注意：当图像压缩分辨率为VGA时，支持0=CIF, 1=QCIF, 2=D1抓图， }
{-当分辨率为3=UXGA(1600x1200), 4=SVGA(800x600), 5=HD720p(1280x720),6=VGA,7=XVGA, 8=HD900p }
{=仅支持当前分辨率的抓图 }
    wPicSize: Word;
{= 0=CIF, 1=QCIF, 2=D1 3=UXGA(1600x1200), 4=SVGA(800x600), 5=HD720p(1280x720),6=VGA }
    wPicQuality: Word;
{= 图片质量系数 0-最好 1-较好 2-一般 }
  end {NET_DVR_JPEGPARA};
  LPNET_DVR_JPEGPARA = ^NET_DVR_JPEGPARA;

{+// aux video out parameter*/ }
{///辅助输出参数配置 }
type
  NET_DVR_AUXOUTCFG = record
    dwSize: LongInt;
    dwAlarmOutChan: LongInt;
{= 选择报警弹出大报警通道切换时间：1画面的输出通道: 0:主输出/1:辅1/2:辅2/3:辅3/4:辅4 }
    dwAlarmChanSwitchTime: LongInt;
{= :1秒 - 10:10秒 }
    dwAuxSwitchTime: Array[0..MAX_AUXOUT-1] of LongInt;
{= 辅助输出切换时间: 0-不切换,1-5s,2-10s,3-20s,4-30s,5-60s,6-120s,7-300s }
    byAuxOrder: Array[0..MAX_AUXOUT-1,0..MAX_WINDOW-1] of BYTE;
{= 辅助输出预览顺序, 0xff表示相应的窗口不预览 }
  end {NET_DVR_AUXOUTCFG};
  LPNET_DVR_AUXOUTCFG = ^NET_DVR_AUXOUTCFG;


{///ntp }
type
  NET_DVR_NTPPARA = record
    sNTPServer: Array[0..64-1] of BYTE;
{= Domain Name or IP addr of NTP server }
    wInterval: Word;
{= adjust time interval(hours) }
    byEnableNTP: BYTE;
{= enable NPT client 0-no，1-yes }
    cTimeDifferenceH: Char;
{= 与国际标准时间的 小时偏移-12 ... +13 }
    cTimeDifferenceM: Char;
{= 与国际标准时间的 分钟偏移0, 30, 45 }
    res1: BYTE;
    wNtpPort: Word;
{= ntp server port 9000新增 设备默认为123 }
    res2: Array[0..8-1] of BYTE;
  end {NET_DVR_NTPPARA};
  LPNET_DVR_NTPPARA = ^NET_DVR_NTPPARA;

{///ddns }
type
  NET_DVR_DDNSPARA = record
    sUsername: Array[0..NAME_LEN-1] of BYTE;
{= DDNS账号用户名/密码 }
    sPassword: Array[0..PASSWD_LEN-1] of BYTE;
    sDomainName: Array[0..64-1] of BYTE;
{= 域名 }
    byEnableDDNS: BYTE;
{=是否应用 0-否，1-是 }
    res: Array[0..15-1] of BYTE;
  end {NET_DVR_DDNSPARA};
  LPNET_DVR_DDNSPARA = ^NET_DVR_DDNSPARA;


type
  NET_DVR_DDNSPARA_EX = record
    byHostIndex: BYTE;
{= 0-Hikvision DNS(保留) 1－Dyndns 2－PeanutHull(花生壳), 3-希网3322 }
    byEnableDDNS: BYTE;
{=是否应用DDNS 0-否，1-是 }
    wDDNSPort: Word;
{= DDNS端口号 }
    sUsername: Array[0..NAME_LEN-1] of BYTE;
{= DDNS用户名 }
    sPassword: Array[0..PASSWD_LEN-1] of BYTE;
{= DDNS密码 }
    sDomainName: Array[0..MAX_DOMAIN_NAME-1] of BYTE;
{= 设备配备的域名地址 }
    sServerName: Array[0..MAX_DOMAIN_NAME-1] of BYTE;
{= DDNS 对应的服务器地址，可以是IP地址或域名 }
    byRes: Array[0..16-1] of BYTE;
  end {NET_DVR_DDNSPARA_EX};
  LPNET_DVR_DDNSPARA_EX = ^NET_DVR_DDNSPARA_EX;

{///9000扩展 }
type
  TstruDDNS = record
    sUsername: Array[0..NAME_LEN-1] of BYTE;  //DDNS账号用户名
    sPassword: Array[0..PASSWD_LEN-1] of BYTE;//密码 }
    sDomainName: Array[0..MAX_DOMAIN_NAME-1] of BYTE; //设备配备的域名地址
    sServerName: Array[0..MAX_DOMAIN_NAME-1] of BYTE; //DDNS协议对应的服务器地址，可以是IP地址或域名
    wDDNSPort: Word; //端口号
    byRes: Array[0..10-1] of BYTE;
  end;

  NET_DVR_DDNSPARA_V30 = record
    byEnableDDNS: BYTE;
    byHostIndex: BYTE;//0-Hikvision DNS(保留) 1－Dyndns 2－PeanutHull(花生壳) 3-希网3322
    byRes1: Array[0..2-1] of BYTE;
    struDDNS: Array[0..MAX_DDNS_NUMS-1] of TstruDDNS;
    byRes2: Array[0..16-1]  of Byte;
  end;
  LPNET_DVR_DDNSPARA_V30 = ^NET_DVR_DDNSPARA_V30;


{///email }
type
  NET_DVR_EMAILPARA = record
    sUsername: Array[0..64-1] of BYTE;
{= 邮件账号/密码 }
    sPassword: Array[0..64-1] of BYTE;
    sSmtpServer: Array[0..64-1] of BYTE;
    sPop3Server: Array[0..64-1] of BYTE;
    sMailAddr: Array[0..64-1] of BYTE;
{= email }
    sEventMailAddr1: Array[0..64-1] of BYTE;
{= 上传报警/异常等的email }
    sEventMailAddr2: Array[0..64-1] of BYTE;
    res: Array[0..16-1] of BYTE;
  end {NET_DVR_EMAILPARA};
  LPNET_DVR_EMAILPARA = ^NET_DVR_EMAILPARA;

{///网络参数配置 }
type
  NET_DVR_NETAPPCFG = record
    dwSize: LongInt;
    sDNSIp: Array[0..16-1] of Char;
{= DNS服务器地址 }
    struNtpClientParam: NET_DVR_NTPPARA;
{= NTP参数 }
    struDDNSClientParam: NET_DVR_DDNSPARA;
{= DDNS参数 }
    res: Array[0..464-1] of BYTE;
{= 保留 }
  end {NET_DVR_NETAPPCFG};
  LPNET_DVR_NETAPPCFG = ^NET_DVR_NETAPPCFG;

{///nfs结构配置 }
type
  NET_DVR_SINGLE_NFS = record
    sNfsHostIPAddr: Array[0..16-1] of Char;
    sNfsDirectory: Array[0..PATHNAME_LEN-1] of BYTE;
  end {NET_DVR_SINGLE_NFS};
  LPNET_DVR_SINGLE_NFS = ^NET_DVR_SINGLE_NFS;

type
  NET_DVR_NFSCFG = record
    dwSize: LongInt;
    struNfsDiskParam: Array[0..MAX_NFS_DISK-1] of NET_DVR_SINGLE_NFS;
  end {NET_DVR_NFSCFG};
  LPNET_DVR_NFSCFG = ^NET_DVR_NFSCFG;

{///巡航点配置(HIK IP快球专用) }
type
  NET_DVR_CRUISE_POINT = record
    PresetNum: BYTE;
    Dwell: BYTE;
    Speed: BYTE;
    Reserve: BYTE;
  end {NET_DVR_CRUISE_POINT};
  LPNET_DVR_CRUISE_POINT = ^NET_DVR_CRUISE_POINT;

type
  NET_DVR_CRUISE_RET = record
    struCruisePoint: Array[0..32-1] of NET_DVR_CRUISE_POINT;
  end {NET_DVR_CRUISE_RET};
  LPNET_DVR_CRUISE_RET = ^NET_DVR_CRUISE_RET;

{///8000-2.2 }
{///所有硬盘配置参数 }
type
  tagNET_DVR_ALL_HD_CFG = record
    dwSize: LongInt;
    byThreshold: BYTE;
    byRes: Array[0..4-1] of BYTE;
  end {tagNET_DVR_ALL_HD_CFG};


{+//***********************************多路解码器(begin)***************************************/ }
type
  NET_DVR_NETCFG_OTHER = record
    dwSize: LongInt;
    sFirstDNSIP: Array[0..16-1] of Char;
    sSecondDNSIP: Array[0..16-1] of Char;
    sRes: Array[0..32-1] of Char;
  end {NET_DVR_NETCFG_OTHER};
  LPNET_DVR_NETCFG_OTHER = ^NET_DVR_NETCFG_OTHER;

type
  NET_DVR_MATRIX_DECINFO = record
    sDVRIP: Array[0..16-1] of Char;
{= DVR IP地址 }
    wDVRPort: Word;
{= 端口号 }
    byChannel: BYTE;
{= 通道号 }
    byTransProtocol: BYTE;
{= 传输协议类型 0-TCP, 1-UDP }
    byTransMode: BYTE;
{= 传输码流模式 0－主码流 1－子码流 }
    byRes: Array[0..3-1] of BYTE;
    sUserName: Array[0..NAME_LEN-1] of BYTE;
{= 监控主机登陆帐号 }
    sPassword: Array[0..PASSWD_LEN-1] of BYTE;
{= 监控主机密码 }
  end {NET_DVR_MATRIX_DECINFO};
  LPNET_DVR_MATRIX_DECINFO = ^NET_DVR_MATRIX_DECINFO;

{///启动/停止动态解码 }
type
  NET_DVR_MATRIX_DYNAMIC_DEC = record
    dwSize: LongInt;
    struDecChanInfo: NET_DVR_MATRIX_DECINFO;
{= 动态解码通道信息 }
  end {NET_DVR_MATRIX_DYNAMIC_DEC};
  LPNET_DVR_MATRIX_DYNAMIC_DEC = ^NET_DVR_MATRIX_DYNAMIC_DEC;

type
  NET_DVR_MATRIX_DEC_CHAN_STATUS = record
    dwSize: LongInt;
    dwIsLinked: LongInt;
{= 解码通道状态 0－休眠 1－正在连接 2－已连接 3-正在解码 }
    dwStreamCpRate: LongInt;
{= Stream copy rate, X kbits/second }
    cRes: Array[0..64-1] of Char;
{= 保留 }
  end {NET_DVR_MATRIX_DEC_CHAN_STATUS};
  LPNET_DVR_MATRIX_DEC_CHAN_STATUS = ^NET_DVR_MATRIX_DEC_CHAN_STATUS;

type
  NET_DVR_MATRIX_DEC_CHAN_INFO = record
    dwSize: LongInt;
    struDecChanInfo: NET_DVR_MATRIX_DECINFO;
{= 解码通道信息 }
    dwDecState: LongInt;
{= 0-动态解码 1－循环解码 2－按时间回放 3－按文件回放 }
    StartTime: NET_DVR_TIME;
{= 按时间回放开始时间 }
    StopTime: NET_DVR_TIME;
{= 按时间回放停止时间 }
    sFileName: Array[0..128-1] of Char;
{= 按文件回放文件名 }
  end {NET_DVR_MATRIX_DEC_CHAN_INFO};
  LPNET_DVR_MATRIX_DEC_CHAN_INFO = ^NET_DVR_MATRIX_DEC_CHAN_INFO;

{///连接的通道配置 2007-11-05 }
type
  NET_DVR_MATRIX_DECCHANINFO = record
    dwEnable: LongInt;
{= 是否启用 0－否 1－启用 }
    struDecChanInfo: NET_DVR_MATRIX_DECINFO;
{= 轮循解码通道信息 }
  end {NET_DVR_MATRIX_DECCHANINFO};
  LPNET_DVR_MATRIX_DECCHANINFO = ^NET_DVR_MATRIX_DECCHANINFO;

{///2007-11-05 新增每个解码通道的配置 }
type
  NET_DVR_MATRIX_LOOP_DECINFO = record
    dwSize: LongInt;
    dwPoolTime: LongInt;
{=轮巡时间 }
    struchanConInfo: Array[0..MAX_CYCLE_CHAN-1] of NET_DVR_MATRIX_DECCHANINFO;
  end {NET_DVR_MATRIX_LOOP_DECINFO};
  LPNET_DVR_MATRIX_LOOP_DECINFO = ^NET_DVR_MATRIX_LOOP_DECINFO;

{///2007-12-22 }
type
  TTY_CONFIG = record
    baudrate: BYTE;
{= 波特率 }
    databits: BYTE;
{= 数据位 }
    stopbits: BYTE;
{= 停止位 }
    parity: BYTE;
{= 奇偶校验位 }
    flowcontrol: BYTE;
{= 流控 }
    res: Array[0..3-1] of BYTE;
  end {TTY_CONFIG};
  LPTTY_CONFIG = ^TTY_CONFIG;

type
  NET_DVR_MATRIX_TRAN_CHAN_INFO = record
    byTranChanEnable: BYTE;
{= 当前透明通道是否打开 0：关闭 1：打开 }
{+// }
{-* 多路解码器本地有1个485串口，1个232串口都可以作为透明通道,设备号分配如下： }
{-* 0 RS485 }
{-* 1 RS232 Console }
{= }
    byLocalSerialDevice: BYTE;
{= Local serial device }
{+// }
{-* 远程串口输出还是两个,一个RS232，一个RS485 }
{-* 1表示232串口 }
{-* 2表示485串口 }
{= }
    byRemoteSerialDevice: BYTE;
{= Remote output serial device }
    res1: BYTE;
{= 保留 }
    sRemoteDevIP: Array[0..16-1] of Char;
{= Remote Device IP }
    wRemoteDevPort: Word;
{= Remote Net Communication Port }
    res2: Array[0..2-1] of BYTE;
{= 保留 }
    RemoteSerialDevCfg: TTY_CONFIG;
  end {NET_DVR_MATRIX_TRAN_CHAN_INFO};
  LPNET_DVR_MATRIX_TRAN_CHAN_INFO = ^NET_DVR_MATRIX_TRAN_CHAN_INFO;

type
  NET_DVR_MATRIX_TRAN_CHAN_CONFIG = record
    dwSize: LongInt;
    by232IsDualChan: BYTE;
{= 设置哪路232透明通道是全双工的 取值1到MAX_SERIAL_NUM }
    by485IsDualChan: BYTE;
{= 设置哪路485透明通道是全双工的 取值1到MAX_SERIAL_NUM }
    res: Array[0..2-1] of BYTE;
{= 保留 }
    struTranInfo: Array[0..MAX_SERIAL_NUM-1] of NET_DVR_MATRIX_TRAN_CHAN_INFO;
{=同时支持建立MAX_SERIAL_NUM个透明通道 }
  end {NET_DVR_MATRIX_TRAN_CHAN_CONFIG};
  LPNET_DVR_MATRIX_TRAN_CHAN_CONFIG = ^NET_DVR_MATRIX_TRAN_CHAN_CONFIG;

{///2007-12-24 Merry Christmas Eve... }
type
  NET_DVR_MATRIX_DEC_REMOTE_PLAY = record
    dwSize: LongInt;
    sDVRIP: Array[0..16-1] of Char;
{= DVR IP地址 }
    wDVRPort: Word;
{= 端口号 }
    byChannel: BYTE;
{= 通道号 }
    byReserve: BYTE;
    sUserName: Array[0..NAME_LEN-1] of BYTE;
{= 用户名 }
    sPassword: Array[0..PASSWD_LEN-1] of BYTE;
{= 密码 }
    dwPlayMode: LongInt;
{= 0－按文件 1－按时间 }
    StartTime: NET_DVR_TIME;
    StopTime: NET_DVR_TIME;
    sFileName: Array[0..128-1] of Char;
  end {NET_DVR_MATRIX_DEC_REMOTE_PLAY};
  LPNET_DVR_MATRIX_DEC_REMOTE_PLAY = ^NET_DVR_MATRIX_DEC_REMOTE_PLAY;

{+// 文件播放命令*/ }
//const
  //NET_DVR_PLAYSTART =1; {//开始播放}
//const
  //NET_DVR_PLAYSTOP =2;{//停止播放}
//const
  //NET_DVR_PLAYPAUSE =3;{//暂停播放}
//const
  //NET_DVR_PLAYRESTART =4;{//恢复播放}
//const
  //NET_DVR_PLAYFAST =5;{//快放}
//const
 //NET_DVR_PLAYSLOW =6;{//慢放}
//const
  //NET_DVR_PLAYNORMAL =7;{//正常速度}
//const
  //NET_DVR_PLAYSTARTAUDIO =9;{//打开声音}
//const
  //NET_DVR_PLAYSTOPAUDIO = 10;{//关闭声音}
//const
  //NET_DVR_PLAYSETPOS = 12;{//改变文件回放的进度}

type
  NET_DVR_MATRIX_DEC_REMOTE_PLAY_CONTROL = record
    dwSize: LongInt;
    dwPlayCmd: LongInt;
{= 播放命令 见文件播放命令 }
    dwCmdParam: LongInt;
{= 播放命令参数 }
  end {NET_DVR_MATRIX_DEC_REMOTE_PLAY_CONTROL};
  LPNET_DVR_MATRIX_DEC_REMOTE_PLAY_CONTROL = ^NET_DVR_MATRIX_DEC_REMOTE_PLAY_CONTROL;

type
  NET_DVR_MATRIX_DEC_REMOTE_PLAY_STATUS = record
    dwSize: LongInt;
    dwCurMediaFileLen: LongInt;
{= 当前播放的媒体文件长度 }
    dwCurMediaFilePosition: LongInt;
{= 当前播放文件的播放位置 }
    dwCurMediaFileDuration: LongInt;
{= 当前播放文件的总时间 }
    dwCurPlayTime: LongInt;
{= 当前已经播放的时间 }
    dwCurMediaFIleFrames: LongInt;
{= 当前播放文件的总帧数 }
    dwCurDataType: LongInt;
{= 当前传输的数据类型，19-文件头，20-流数据， 21-播放结束标志 }
    res: Array[0..72-1] of BYTE;
  end {NET_DVR_MATRIX_DEC_REMOTE_PLAY_STATUS};
  LPNET_DVR_MATRIX_DEC_REMOTE_PLAY_STATUS = ^NET_DVR_MATRIX_DEC_REMOTE_PLAY_STATUS;
{+//***********************************多路解码器(end)***************************************/ }

type
  NET_DVR_EMAILCFG = record
{= 12 bytes }
    dwSize: LongInt;
    sUserName: Array[0..32-1] of Char;
    sPassWord: Array[0..32-1] of Char;
    sFromName: Array[0..32-1] of Char;
{- Sender* }
{=char sFromAddr[48]; /* Sender address }
    sToName1: Array[0..32-1] of Char;
{= Receiver1 }
    sToName2: Array[0..32-1] of Char;
{= Receiver2 }
    sToAddr1: Array[0..48-1] of Char;
{= Receiver address1 }
    sToAddr2: Array[0..48-1] of Char;
{= Receiver address2 }
    sEmailServer: Array[0..32-1] of Char;
{= Email server address }
    byServerType: BYTE;
{= Email server type: 0-SMTP, 1-POP, 2-IMTP… }
    byUseAuthen: BYTE;
{= Email server authentication method: 1-enable, 0-disable }
    byAttachment: BYTE;
{= enable attachment }
    byMailinterval: BYTE;
{= mail interval 0-2s, 1-3s, 2-4s. 3-5s }
  end {NET_DVR_EMAILCFG};
  LPNET_DVR_EMAILCFG = ^NET_DVR_EMAILCFG;

type
  NET_DVR_COMPRESSIONCFG_NEW = record
    dwSize: LongInt;
    struLowCompression: NET_DVR_COMPRESSION_INFO_EX;
    struEventCompression: NET_DVR_COMPRESSION_INFO_EX;
  end {NET_DVR_COMPRESSIONCFG_NEW};
  LPNET_DVR_COMPRESSIONCFG_NEW = ^NET_DVR_COMPRESSIONCFG_NEW;

{///球机位置信息 }
type
  NET_DVR_PTZPOS = record
    wAction: Word;
    wPanPos: Word;
    wTiltPos: Word;
    wZoomPos: Word;
  end {NET_DVR_PTZPOS};
  LPNET_DVR_PTZPOS = ^NET_DVR_PTZPOS;

{///球机范围信息 }
type
  NET_DVR_PTZSCOPE = record
    wPanPosMin: Word;
    wPanPosMax: Word;
    wTiltPosMin: Word;
    wTiltPosMax: Word;
    wZoomPosMin: Word;
    wZoomPosMax: Word;
  end {NET_DVR_PTZSCOPE};
  LPNET_DVR_PTZSCOPE = ^NET_DVR_PTZSCOPE;

{///rtsp配置 ipcamera专用 }
type
  NET_DVR_RTSPCFG = record
    dwSize: LongInt;
    wPort: Word;
    byReserve: Array[0..54-1] of BYTE;
  end {NET_DVR_RTSPCFG};
  LPNET_DVR_RTSPCFG = ^NET_DVR_RTSPCFG;


{+//*******************************接口参数结构(begin)*********************************/ }

{///NET_DVR_Login()参数结构 }
type
  NET_DVR_DEVICEINFO = record
    sSerialNumber: Array[0..SERIALNO_LEN-1] of BYTE;
    byAlarmInPortNum: BYTE;
    byAlarmOutPortNum: BYTE;
    byDiskNum: BYTE;
    byDVRType: BYTE;
    byChanNum: BYTE;
    byStartChan: BYTE;
  end {NET_DVR_DEVICEINFO};
  LPNET_DVR_DEVICEINFO = ^NET_DVR_DEVICEINFO;

{///NET_DVR_Login_V30()参数结构 }
type
  NET_DVR_DEVICEINFO_V30 = record
    sSerialNumber: Array[0..SERIALNO_LEN-1] of BYTE;
    byAlarmInPortNum: BYTE;
    byAlarmOutPortNum: BYTE;
    byDiskNum: BYTE;
    byDVRType: BYTE;
    byChanNum: BYTE;
    byStartChan: BYTE;
    byAudioChanNum: BYTE;
    byIPChanNum: BYTE;
    byRes1: Array[0..24-1] of BYTE;
  end {NET_DVR_DEVICEINFO_V30};
  LPNET_DVR_DEVICEINFO_V30 = ^NET_DVR_DEVICEINFO_V30;

{///sdk网络环境枚举变量，用于远程升级 }
type
  _SDK_NET_ENV = (
    LOCAL_AREA_NETWORK = 0,
    WIDE_AREA_NETWORK  );
  SDK_NETWORK_ENVIRONMENT =  _SDK_NET_ENV;

{///显示模式 }
type
  DISPLAY_MODE = (
    NORMALMODE = 0,
    OVERLAYMODE  );

{///发送模式 }
type
  SEND_MODE = (
    PTOPTCPMODE = 0, 
    PTOPUDPMODE, 
    MULTIMODE, 
    RTPMODE, 
    RESERVEDMODE  );

{///抓图模式 }
type
  CAPTURE_MODE = (
    BMP_MODE = 0,
    JPEG_MODE = 1 );

{///实时声音模式 }
type
  REALSOUND_MODE = (
    MONOPOLIZE_MODE = 1,
    SHARE_MODE = 2  );

{///软解码预览参数 }
type
  NET_DVR_CLIENTINFO = record
    lChannel: LongInt;
    lLinkMode: LongInt;
    hPlayWnd: HWND;
    sMultiCastIP: PChar;
  end {NET_DVR_CLIENTINFO};
  LPNET_DVR_CLIENTINFO = ^NET_DVR_CLIENTINFO;

{///SDK状态信息(9000新增) }
type
  NET_DVR_SDKSTATE = record
    dwTotalLoginNum: LongInt;
    dwTotalRealPlayNum: LongInt;
    dwTotalPlayBackNum: LongInt;
    dwTotalAlarmChanNum: LongInt;
    dwTotalFormatNum: LongInt;
    dwTotalFileSearchNum: LongInt;
    dwTotalLogSearchNum: LongInt;
    dwTotalSerialNum: LongInt;
    dwTotalUpgradeNum: LongInt;
    dwTotalVoiceComNum: LongInt;
    dwTotalBroadCastNum: LongInt;
    dwRes: Array[0..10-1] of LongInt;
  end {NET_DVR_SDKSTATE};
  LPNET_DVR_SDKSTATE = ^NET_DVR_SDKSTATE;

{///SDK功能支持信息(9000新增) }
type
  NET_DVR_SDKABL = record
    dwMaxLoginNum: LongInt;
    dwMaxRealPlayNum: LongInt;
    dwMaxPlayBackNum: LongInt;
    dwMaxAlarmChanNum: LongInt;
    dwMaxFormatNum: LongInt;
    dwMaxFileSearchNum: LongInt;
    dwMaxLogSearchNum: LongInt;
    dwMaxSerialNum: LongInt;
    dwMaxUpgradeNum: LongInt;
    dwMaxVoiceComNum: LongInt;
    dwMaxBroadCastNum: LongInt;
    dwRes: Array[0..10-1] of LongInt;
  end {NET_DVR_SDKABL};
  LPNET_DVR_SDKABL = ^NET_DVR_SDKABL;

{///报警设备信息 }
type
  NET_DVR_ALARMER = record
    byUserIDValid: BYTE;
{= userid是否有效 0-无效，1-有效 }
    bySerialValid: BYTE;
{= 序列号是否有效 0-无效，1-有效 }
    byVersionValid: BYTE;
{= 版本号是否有效 0-无效，1-有效 }
    byDeviceNameValid: BYTE;
{= 设备名字是否有效 0-无效，1-有效 }
    byMacAddrValid: BYTE;
{= MAC地址是否有效 0-无效，1-有效 }
    byLinkPortValid: BYTE;
{= login端口是否有效 0-无效，1-有效 }
    byDeviceIPValid: BYTE;
{= 设备IP是否有效 0-无效，1-有效 }
    bySocketIPValid: BYTE;
{= socket ip是否有效 0-无效，1-有效 }
    lUserID: LongInt;
{= NET_DVR_Login()返回值, 布防时有效 }
    sSerialNumber: Array[0..SERIALNO_LEN-1] of BYTE;
{= 序列号 }
    dwDeviceVersion: LongInt;
{= 版本信息 高16位表示主版本，低16位表示次版本 }
    sDeviceName: Array[0..NAME_LEN-1] of Char;
{= 设备名字 }
    byMacAddr: Array[0..MACADDR_LEN-1] of BYTE;
{= MAC地址 }
    wLinkPort: Word;
{= link port }
    sDeviceIP: Array[0..128-1] of Char;
{= IP地址 }
    sSocketIP: Array[0..128-1] of Char;
{= 报警主动上传时的socket IP地址 }
    byIpProtocol: BYTE;
{= Ip协议 0-IPV4, 1-IPV6 }
    byRes2: Array[0..11-1] of BYTE;
  end {NET_DVR_ALARMER};
  LPNET_DVR_ALARMER = ^NET_DVR_ALARMER;

{///硬解码显示区域参数(子结构) }
type
  NET_DVR_DISPLAY_PARA = record
    bToScreen: LongInt;
    bToVideoOut: LongInt;
    nLeft: LongInt;
    nTop: LongInt;
    nWidth: LongInt;
    nHeight: LongInt;
    nReserved: LongInt;
  end {NET_DVR_DISPLAY_PARA};
  LPNET_DVR_DISPLAY_PARA = ^NET_DVR_DISPLAY_PARA;

{///硬解码预览参数 }
type
  NET_DVR_CARDINFO = record
    lChannel: LongInt;
    lLinkMode: LongInt;
    sMultiCastIP: PChar;
    struDisplayPara: NET_DVR_DISPLAY_PARA;
  end {NET_DVR_CARDINFO};
  LPNET_DVR_CARDINFO = ^NET_DVR_CARDINFO;

{///录象文件参数 }
type
  NET_DVR_FIND_DATA = record
    sFileName: Array[0..100-1] of Char;
    struStartTime: NET_DVR_TIME;
    struStopTime: NET_DVR_TIME;
    dwFileSize: LongInt;
  end {NET_DVR_FIND_DATA};
  LPNET_DVR_FIND_DATA = ^NET_DVR_FIND_DATA;

{///录象文件参数(9000) }
type
  NET_DVR_FINDDATA_V30 = record
    sFileName: Array[0..100-1] of Char;
    struStartTime: NET_DVR_TIME;
    struStopTime: NET_DVR_TIME;
    dwFileSize: LongInt;
    sCardNum: Array[0..32-1] of Char;
    byLocked: BYTE;
    byRes: Array[0..3-1] of BYTE;
  end {NET_DVR_FINDDATA_V30};
  LPNET_DVR_FINDDATA_V30 = ^NET_DVR_FINDDATA_V30;

{///录象文件参数(带卡号) }
type
  NET_DVR_FINDDATA_CARD = record
    sFileName: Array[0..100-1] of Char;
    struStartTime: NET_DVR_TIME;
    struStopTime: NET_DVR_TIME;
    dwFileSize: LongInt;
    sCardNum: Array[0..32-1] of Char;
  end {NET_DVR_FINDDATA_CARD};
  LPNET_DVR_FINDDATA_CARD = ^NET_DVR_FINDDATA_CARD;


{///录象文件查找条件结构 }
type
  NET_DVR_FILECOND = record
    lChannel: LongInt;
    dwFileType: LongInt;
{///3-报警|移动侦测 4-报警&移动侦测 5-命令触发 6-手动录像 }
    dwIsLocked: LongInt;
    dwUseCardNo: LongInt;
    sCardNumber: Array[0..32-1] of BYTE;
    struStartTime: NET_DVR_TIME;
    struStopTime: NET_DVR_TIME;
  end {NET_DVR_FILECOND};
  LPNET_DVR_FILECOND = ^NET_DVR_FILECOND;


{///云台区域选择放大缩小(HIK 快球专用) }
type
  NET_DVR_POINT_FRAME = record
    xTop: Integer;
    yTop: Integer;
    xBottom: Integer;
    yBottom: Integer;
    bCounter: Integer;
  end {NET_DVR_POINT_FRAME};
  LPNET_DVR_POINT_FRAME = ^NET_DVR_POINT_FRAME;

{///语音对讲参数 }
type
  NET_DVR_COMPRESSION_AUDIO = record
    byAudioEncType: BYTE;
    byres: Array[0..7-1] of BYTE;
  end {NET_DVR_COMPRESSION_AUDIO};
  LPNET_DVR_COMPRESSION_AUDIO = ^NET_DVR_COMPRESSION_AUDIO;

type
  NET_ITC_INTERVAL_PARAM =record
    byIntervalType:BYTE; //间隔类型（默认按时间），0-时间起效,1-距离起效
    byRes1:array [0..2] of BYTE;
    wInterval :array [0..MAX_INTERVAL_NUM-1] of WORD;//连拍间隔时间（单位ms）或连拍间隔距离（单位分米），当byIntervalType为0时，表示间隔时间，当byIntervalType为1时，表示距离
    byRes:array [0..7] of BYTE;
  end;
  LPNET_ITC_INTERVAL_PARAM=^NET_ITC_INTERVAL_PARAM;

type TuRegion = record
  case integer of
      0:
        (struRect: NET_VCA_RECT);  //矩形区域
      1:
        (struPolygon: NET_ITC_POLYGON); //多边形区域
  end;

type
  NET_ITC_PLATE_RECOG_REGION_PARAM= record
    byMode:BYTE; //区域类型，0-矩形，1-多边形
    byRes1:array [0..2] of BYTE;
    {union
    NET_VCA_RECT struRect;  //矩形区域
    NET_ITC_POLYGON struPolygon; //多边形区域
    uRegion; }
    uRegion:TuRegion;
    byRes: array [0..15] of BYTE;     //保留
  end;
  LPNET_ITC_PLATE_RECOG_REGION_PARAM=^NET_ITC_PLATE_RECOG_REGION_PARAM;

type
  NET_ITC_LANE_PARAM =record    //424
    byEnable:BYTE; //是否启用该车道，0-不启用，1-启用
    byRelatedDriveWay:BYTE;//关联的车道号
    wDistance:WORD; //线圈距离，计算速度
    wTrigDelayTime:WORD; //触发延迟时间（默认200），单位：毫秒
    byTrigDelayDistance:BYTE; //触发延迟距离（默认0），单位：分米
    bySpeedCapEn:BYTE; //是否启用超速抓拍，0-否，1-是
    bySignSpeed:BYTE;//标志限速，单位km/h
    bySpeedLimit:BYTE;//限速值，单位km/h
    bySnapTimes:BYTE; //抓拍次数（默认1），0-不抓拍，非0-连拍次数，最大5
    byOverlayDriveWay:BYTE; //OSD叠加的车道号
    struInterval: NET_ITC_INTERVAL_PARAM ; //抓拍间隔参数
    byRelatedIOOut:array [0..MAX_IOOUT_NUM-1] of BYTE ; //关联的IO输出口，可以同时关联多个
    byFlashMode:BYTE;   //闪光灯闪烁模式，0-同时闪，1-轮流闪
    byCartSignSpeed:BYTE;//标志限速(大车)，单位km/h
    byCartSpeedLimit:BYTE;//限速值（大车），单位km/h
    byRes2:BYTE;
    struPlateRecog:array[0..MAX_LANEAREA_NUM-1] of NET_ITC_PLATE_RECOG_REGION_PARAM; //车道牌识参数
    byRes:array [0..15] of BYTE;
  end;
  LPNET_ITC_LANE_PARAM=^NET_ITC_LANE_PARAM;

type
  NET_ITC_RADAR_PARAM =record   //24
    byRadarType:BYTE; //雷达类型，0-无雷达,1-安道雷雷达，2-奥利维亚，3-川速微波，0xff-其它类型
    byLevelAngle:BYTE;   //与水平线所成角度,默认为25°(0到90度)
    wRadarSensitivity:WORD; //雷达灵敏度
    byRes:array [0..19] of BYTE;
  end;
  LPNET_ITC_RADAR_PARAM=^NET_ITC_RADAR_PARAM;

type
  NET_ITC_PLATE_RECOG_PARAM =record
    byDefaultCHN: array [0..MAX_CHJC_NUM-1] of BYTE;
    byEnable: BYTE;
    dwRecogMode: DWORD;
    byVehicleLogoRecog: BYTE;
    byRes: array [0..31-1] of BYTE;
  end;
  LPNET_ITC_PLATE_RECOG_PARAM = ^NET_ITC_PLATE_RECOG_PARAM;

type
  NET_ITC_POST_RS485_RADAR_PARAM  = record
    byRelatedLaneNum: BYTE;
    byRes1: array[0..3-1] of BYTE;
    struPlateRecog: NET_ITC_PLATE_RECOG_PARAM;
    struLane: array[0..MAX_ITC_LANE_NUM-1] of NET_ITC_LANE_PARAM;
    struRadar: NET_ITC_RADAR_PARAM;
    byRes: array[0..32-1] of BYTE;
  end;
  LPNET_ITC_POST_RS485_RADAR_PARAM = ^NET_ITC_POST_RS485_RADAR_PARAM;

type
  NET_ITC_TRIGGER_PARAM_UNION= record //2644 //4280
    struPostRadar:NET_ITC_POST_RS485_RADAR_PARAM; //（卡口）RS485雷达参数
    uLen :array [0..1635] of byte ;
  end;
  LPNET_ITC_TRIGGER_PARAM_UNION=^NET_ITC_TRIGGER_PARAM_UNION;

type
  NET_ITC_SINGLE_TRIGGERCFG= record  //72  +  4280  =2716     //4352
    byEnable:BYTE; //是否启用该触发模式，0-否，1-是
    byRes1:array [0..2] of BYTE  ;
    dwTriggerType:DWORD; //触发类型，详见ITC_TRIGGERMODE_TYPE
    uTriggerParam: NET_ITC_TRIGGER_PARAM_UNION ; //触发参数
    byRes:array [0..63] of  BYTE ;
  end;
  LPNET_ITC_SINGLE_TRIGGERCFG=^NET_ITC_SINGLE_TRIGGERCFG;

//触发参数结构
type
  NET_ITC_TRIGGERCFG= record      //2716 +36     //4388
    dwSize:DWORD;   //结构长度
    struTriggerParam:NET_ITC_SINGLE_TRIGGERCFG;  //单个触发参数
    byRes: array [0..31] of  BYTE ;
  end;
  LPNET_ITC_TRIGGERCFG=^NET_ITC_TRIGGERCFG;

type
  NET_ITS_OVERLAP_SINGLE_ITEM_PARAM= record
  byRes1:array [0..1] of  BYTE;                   // 保留
  byItemType:BYTE;   //类型，详见OVERLAP_ITEM_TYPE
  byChangeLineNum:BYTE;     //叠加项后的换行数[0-10](默认0)
  bySpaceNum:BYTE;       //叠加项后的空格数[0-255](默认0)
  byRes2:array [0..1] of BYTE;
  byEnablePos:BYTE;  //是否启用坐标显示
  wStartPosTop:WORD;    //起始上坐标,只对图片内部叠加有效[0~2448](默认0)
  wStartPosLeft:WORD;    //起始左坐标,只对图片内部叠加有效[0~2448](默认0)
  byRes:array [0..7] of BYTE;
  end;
  LPNET_ITS_OVERLAP_SINGLE_ITEM_PARAM=^NET_ITS_OVERLAP_SINGLE_ITEM_PARAM;

type
  NET_ITS_OVERLAP_ITEM_PARAM= record
  struSingleItem:array [0..MAX_OVERLAP_ITEM_NUM-1] of NET_ITS_OVERLAP_SINGLE_ITEM_PARAM; //单条字符参数
  dwLinePercent:DWORD;  //叠加行百分比(0-100),(默认100)
  dwItemsStlye:DWORD;   //叠加方式：0-横排,1-竖排(默认横排)
  wStartPosTop:WORD;    //起始上坐标,只对图片内部叠加有效[0~2448](默认0)
  wStartPosLeft:WORD;    //起始左坐标,只对图片内部叠加有效[0~2448](默认0)
  wCharStyle:WORD;    //字体类型,0-宋体1-魏体(默认)
  wCharSize:WORD;    //字符大小,0--16x16,1--32x32,2-48x48,3--64x64 (默认)
  wCharInterval:WORD;    //字符间距，[0～16]，可设单位：像素(默认)
  byRes1:array [0..1] of  BYTE;
  dwForeClorRGB:DWORD;      //前景色的RGB值bit0-1:(B) bit2-3:(G) bit4-5:(G) (默认x00FFFFFF-白)
  dwBackClorRGB:DWORD; //背景色的RGB值,只对图片外叠加有效bit0-1:(B) bit2-3:(G) bit4-5:(G) (默认x00000000-黑)
  byColorAdapt:BYTE; //颜色是否自适应0-否1-是
  byParamFillZeroEnble:BYTE;
  byPlateLeftCornerEnable:BYTE;// 车牌小图叠加左上角使能 0-不叠加, 1-叠加
  byRes2:BYTE;
  wStartSPicPosTop:WORD; //起始上坐标,只对图片内部叠加有效[0~2448](默认0)
  wStartSPicPosLeft:WORD; //起始左坐标,只对图片内部叠加有效[0~2448](默认0)
  //OSD叠加位置  0-图片内,1-图片上边缘,2-图片下边缘（合成图专用的是上边缘外）（V3.7）
  byOsdLocate:BYTE;
  byRes:array [0..22] of byte;
  end;
  LPNET_ITS_OVERLAP_ITEM_PARAM=^NET_ITS_OVERLAP_ITEM_PARAM;
 
//叠加项具体信息
type
  NET_ITS_OVERLAP_INFO_PARAM= record
  bySite:array [0..127] of BYTE ;           //地点描述
  byRoadNum:array [0..31] of BYTE ;  //路口编号
  byInstrumentNum:array [0..31] of BYTE ;    //设备编号
  byDirection:array [0..31] of BYTE ;        //方向编号
  byDirectionDesc:array [0..31] of BYTE ;    //方向描述
  byLaneDes:array [0..31] of BYTE ;        //车道描述
  byRes1:array [0..31] of BYTE ;     //保留
  byMonitoringSite1:array [0..43] of BYTE ;  //监测点1信息
  byMonitoringSite2:array [0..31] of BYTE ;  //监测点2信息
  byRes:array [0..63] of BYTE ;  //保留
  end;
  LPNET_ITS_OVERLAP_INFO_PARAM=^NET_ITS_OVERLAP_INFO_PARAM;

type
  NET_ITS_OVERLAP_CFG= record
  dwSize:DWORD;
  byEnable:BYTE; //是否启用，0-不启用，1-启用
  byRes1:array [0..2] of BYTE ;
  struOverLapItem:NET_ITS_OVERLAP_ITEM_PARAM  ; //字符串参数
  struOverLapInfo:NET_ITS_OVERLAP_INFO_PARAM  ;  //字符串内容信息
  byRes:array [0..31] of BYTE ;
  end;
  LPNET_ITS_OVERLAP_CFG=^NET_ITS_OVERLAP_CFG;

type
  NET_ITS_OVERLAPCFG_COND= record
  dwSize: DWORD;
  dwChannel: DWORD;
  dwConfigMode: DWORD;
  byPicModeType: BYTE;
  byRes:array [0..14] of BYTE;
  end;
  LPNET_ITS_OVERLAPCFG_COND = ^NET_ITS_OVERLAPCFG_COND;

 type
  NET_DVR_SETUPALARM_PARAM = record
  dwSize: DWORD;
  byLevel: BYTE;
  byAlarmInfoType: BYTE;
  byRes:array [0..14] of BYTE;
  end;
  LPNET_DVR_SETUPALARM_PARAM = ^NET_DVR_SETUPALARM_PARAM;
{+//*******************************接口参数结构(end)*********************************/ }


{+//*******************************SDK接口函数声明*********************************/ }

function NET_DVR_Init:  BOOL ;stdcall;external 'HCNetSDK.dll' ;

function NET_DVR_Cleanup:  BOOL ;stdcall;external 'HCNetSDK.dll';

function NET_DVR_SetDVRMessage(nMessage: Word; hWnd: HWND):  BOOL ;stdcall;external 'HCNetSDK.dll'
{///NET_DVR_SetDVRMessage的扩展 }


type TfExceptionCallBack = procedure(dwType: Longword;  lUserID: Longint;  lHandle: Longint; pUser: Pointer ); stdcall;
function NET_DVR_SetExceptionCallBack_V30(nMessage: Word; 
                                          hWnd: HWND; 
                                          fExceptionCallBack: TfExceptionCallBack; pUser: Pointer):  BOOL ;stdcall;external 'HCNetSDK.dll' ;


type TfMessCallBack = procedure (lCommand: longint; sDVRIP: PChar;   pBuf: PChar;  dwBufLen: Longword); stdcall;
function NET_DVR_SetDVRMessCallBack( fMessCallBack: TfMessCallBack):  BOOL ;stdcall;external 'HCNetSDK.dll'

type TfMessCallBack_EX = procedure (lCommand: Longint;  lUserID: LongInt;  pBuf: PChar; dwBufLen: Longword );stdcall;
function NET_DVR_SetDVRMessCallBack_EX(fMessCallBack_EX: TfMessCallBack_EX):  BOOL ;stdcall;external 'HCNetSDK.dll'

type TfMessCallBack_NEW = procedure(lCommand: Longint;  sDVRIP: PChar;  pBuf: PChar; dwBufLen: Longword; dwLinkDVRPort: Word );stdcall;
function NET_DVR_SetDVRMessCallBack_NEW(fMessCallBack_NEW: TfMessCallBack_NEW):  BOOL ;stdcall;external 'HCNetSDK.dll'

type TfMessageCallBack = procedure(lCommand: Longint;  sDVRIP: PChar;  pBuf: PChar; dwBufLen: Longword; dwUser: Longword );stdcall;
function NET_DVR_SetDVRMessageCallBack( fMessageCallBack : TfMessageCallBack ; dwUser: Longword):  BOOL ;stdcall;external 'HCNetSDK.dll'

type PNET_DVR_ALARMER = ^NET_DVR_ALARMER; 
type MSGCallBack = procedure(lCommand: Longint; pAlarmer: PNET_DVR_ALARMER; pAlarmInfo: PChar; dwBufLen: Longword; pUser: Pointer);stdcall;
function NET_DVR_SetDVRMessageCallBack_V30(fMessageCallBack: MSGCALLBACK; pUser: Pointer):  BOOL ;stdcall;external 'HCNetSDK.dll'


function NET_DVR_SetConnectTime(dwWaitTime: Longword ;  dwTryTimes: Longword):  BOOL ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_SetReconnect(dwInterval: Longword;  bEnableRecon: Boolean):  BOOL ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_GetSDKVersion(): Longword ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_GetSDKBuildVersion(): Longword;stdcall;external 'HCNetSDK.dll'

function NET_DVR_IsSupport():  integer ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_StartListen(sLocalIP: PChar; 
                             wLocalPort: Word):  BOOL ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_StopListen:  BOOL ;stdcall;external 'HCNetSDK.dll'


function NET_DVR_StartListen_V30(sLocalIP: PChar;  wLocalPort: Word; DataCallback: MSGCallBack;  pUserData: Pointer):  Longint ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_StopListen_V30(lListenHandle: LongInt):  Boolean;stdcall;external 'HCNetSDK.dll'

function NET_DVR_Login(sDVRIP: PChar; 
                       wDVRPort: Word; 
                       sUserName: PChar; 
                       sPassword: PChar; 
                      lpDeviceInfo: LPNET_DVR_DEVICEINFO):  Longint ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_Login_V30(sDVRIP: PAnsiChar;
                           wDVRPort: Word; 
                           sUserName: PAnsiChar;
                           sPassword: PAnsiChar;
                           lpDeviceInfo: LPNET_DVR_DEVICEINFO_V30):  Longint ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_Logout(lUserID: LongInt):  BOOL ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_Logout_V30(lUserID: LongInt):  BOOL ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_GetLastError: Longword ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_GetErrorMsg(pErrorNo: Longint):  PChar ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_SetShowMode(dwShowType: LongInt; 
                             colorKey: TColorRef):  BOOL ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_GetDVRIPByResolveSvr(sServerIP: PChar; 
                                      wServerPort: Word; 
                                      var sDVRName: BYTE; 
                                      wDVRNameLen: Word; 
                                      var sDVRSerialNumber: BYTE; 
                                      wDVRSerialLen: Word; 
                                      sGetIP: PChar):  BOOL ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_GetDVRIPByResolveSvr_EX(sServerIP: PChar; 
                                         wServerPort: Word; 
                                         var sDVRName: Byte; 
                                         wDVRNameLen: Word; 
                                         var sDVRSerialNumber: BYTE; 
                                         wDVRSerialLen: Word; 
                                         sGetIP: PChar; 
                                         var dwPort: LongInt):  BOOL ;stdcall;external 'HCNetSDK.dll'

{///预览相关接口 }

function NET_DVR_RealPlay(lUserID: LongInt; lpClientInfo: LPNET_DVR_CLIENTINFO):  Longint ;stdcall;external 'HCNetSDK.dll'
function NET_DVR_ManualSnap(lUserID:LongInt;lpInter:LPNET_DVR_MANUALSNAP1;lpOuter:LPNET_DVR_PLATE_RESULT) : Boolean;stdcall;external 'HCNetSDK.dll'
function NET_DVR_ContinuousShoot(lUserID:LongInt;lpInter:LPNET_DVR_SNAPCFG): Boolean;stdcall;external 'HCNetSDK.dll'



//Get the data of the video
//type LPByte = ^Byte;
type TfRealDataCallBack_V30 = procedure(lRealHandle: Longint; dwDataType: Longword; pBuffer: LPByte; dwBufSize: Longword; pUser:Pointer);stdcall;
function  NET_DVR_RealPlay_V30 ( lUserID: Longint; lpClientInfo: LPNET_DVR_CLIENTINFO; fRealDataCallBack_V30: TfRealDataCallBack_V30; pUser: Pointer; bBlocked: Boolean): Longint;stdcall; external 'HCNetSDK.dll';

 //Stop Video
function  NET_DVR_StopRealPlay ( lRealHandle : Longint ): Boolean;stdcall;external 'HCNetSDK.dll'

type TfDrawFun = procedure(lRealHandle: longint; hDc: Pointer; dwUser: Longword);stdcall;
function NET_DVR_RigisterDrawFun(lRealHandle: longint; fDrawFun: TfDrawFun): Boolean; stdcall; external 'HCNetSDK.dll'

function NET_DVR_SetPlayerBufNumber(lRealHandle: LongInt; dwBufNum: LongInt):  BOOL ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_ThrowBFrame(lRealHandle: LongInt; 
                             dwNum: LongInt):  BOOL ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_SetAudioMode(dwMode: LongInt):  BOOL ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_OpenSound(lRealHandle: LongInt):  BOOL ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_CloseSound:  BOOL ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_OpenSoundShare(lRealHandle: LongInt):  BOOL ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_CloseSoundShare(lRealHandle: LongInt):  BOOL ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_Volume(lRealHandle: LongInt; 
                        wVolume: Word):  BOOL ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_SaveRealData(lRealHandle: LongInt; 
                              sFileName: PChar):  BOOL ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_StopSaveRealData(lRealHandle: LongInt):  BOOL ;stdcall;external 'HCNetSDK.dll'


Type TfRealDataCallBack = procedure (lRealHandle: Longint; dwDataType: Longword; pBuffer: LPByte; dwBufSize: Longword; dwUser : Longword);  stdcall; 
function NET_DVR_SetRealDataCallBack(lRealHandle: LongInt;  fRealDataCallBack: TfRealDataCallBack; dwUser: LongInt):  BOOL ;stdcall;external 'HCNetSDK.dll'

Type TfStdDataCallBack = procedure (lRealHandle: Longint; dwDataType: Longword; pBuffer: LPByte; dwBufSize: Longword; dwUser : Longword);  stdcall;
function NET_DVR_SetStandardDataCallBack(lRealHandle: LongInt;  fRealDataCallBack: TfRealDataCallBack; dwUser: LongInt):  BOOL ;stdcall;external 'HCNetSDK.dll'


function NET_DVR_CapturePicture(lRealHandle: LongInt; 
                                sPicFileName: PChar):  BOOL ;stdcall;external 'HCNetSDK.dll'

{///动态生成I帧 }

function NET_DVR_MakeKeyFrame(lUserID: LongInt; 
                              lChannel: LongInt):  BOOL ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_MakeKeyFrameSub(lUserID: LongInt; 
                                 lChannel: LongInt):  BOOL ;stdcall;external 'HCNetSDK.dll'

{///云台控制相关接口 }

function NET_DVR_PTZControl(lRealHandle: LongInt; 
                            dwPTZCommand: LongInt; 
                            dwStop: LongInt):  BOOL ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_PTZControl_Other(lUserID: LongInt; 
                                  lChannel: LongInt; 
                                  dwPTZCommand: LongInt; 
                                  dwStop: LongInt):  BOOL ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_TransPTZ(lRealHandle: LongInt; 
                          pPTZCodeBuf: PChar; 
                          dwBufSize: LongInt):  BOOL ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_TransPTZ_Other(lUserID: LongInt; 
                                lChannel: LongInt; 
                                pPTZCodeBuf: PChar; 
                                dwBufSize: LongInt):  BOOL ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_PTZPreset(lRealHandle: LongInt; 
                           dwPTZPresetCmd: LongInt; 
                           dwPresetIndex: LongInt):  BOOL ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_PTZPreset_Other(lUserID: LongInt; 
                                 lChannel: LongInt; 
                                 dwPTZPresetCmd: LongInt; 
                                 dwPresetIndex: LongInt):  BOOL ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_TransPTZ_EX(lRealHandle: LongInt; 
                             pPTZCodeBuf: PChar; 
                             dwBufSize: LongInt):  BOOL ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_PTZControl_EX(lRealHandle: LongInt; 
                               dwPTZCommand: LongInt; 
                               dwStop: LongInt):  BOOL ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_PTZPreset_EX(lRealHandle: LongInt; 
                              dwPTZPresetCmd: LongInt; 
                              dwPresetIndex: LongInt):  BOOL ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_PTZCruise(lRealHandle: LongInt; 
                           dwPTZCruiseCmd: LongInt; 
                           byCruiseRoute: BYTE; 
                           byCruisePoint: BYTE; 
                           wInput: Word):  BOOL ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_PTZCruise_Other(lUserID: LongInt; 
                                 lChannel: LongInt; 
                                 dwPTZCruiseCmd: LongInt; 
                                 byCruiseRoute: BYTE; 
                                 byCruisePoint: BYTE; 
                                 wInput: Word):  BOOL ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_PTZCruise_EX(lRealHandle: LongInt; 
                              dwPTZCruiseCmd: LongInt; 
                              byCruiseRoute: BYTE; 
                              byCruisePoint: BYTE; 
                              wInput: Word):  BOOL ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_PTZTrack(lRealHandle: LongInt; 
                          dwPTZTrackCmd: LongInt):  BOOL ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_PTZTrack_Other(lUserID: LongInt; 
                                lChannel: LongInt; 
                                dwPTZTrackCmd: LongInt):  BOOL ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_PTZTrack_EX(lRealHandle: LongInt; 
                             dwPTZTrackCmd: LongInt):  BOOL ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_PTZControlWithSpeed(lRealHandle: LongInt; 
                                     dwPTZCommand: LongInt; 
                                     dwStop: LongInt; 
                                     dwSpeed: LongInt):  BOOL ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_PTZControlWithSpeed_Other(lUserID: LongInt; 
                                           lChannel: LongInt; 
                                           dwPTZCommand: LongInt; 
                                           dwStop: LongInt; 
                                           dwSpeed: LongInt):  BOOL ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_PTZControlWithSpeed_EX(lRealHandle: LongInt; 
                                        dwPTZCommand: LongInt; 
                                        dwStop: LongInt; 
                                        dwSpeed: LongInt):  BOOL ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_GetPTZCruise(lUserID: LongInt; 
                              lChannel: LongInt; 
                              lCruiseRoute: LongInt; 
                              var lpCruiseRet: NET_DVR_CRUISE_RET):  BOOL ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_PTZMltTrack(lRealHandle: LongInt; 
                             dwPTZTrackCmd: LongInt; 
                             dwTrackIndex: LongInt):  BOOL ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_PTZMltTrack_Other(lUserID: LongInt; 
                                   lChannel: LongInt; 
                                   dwPTZTrackCmd: LongInt; 
                                   dwTrackIndex: LongInt):  BOOL ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_PTZMltTrack_EX(lRealHandle: LongInt; 
                                dwPTZTrackCmd: LongInt; 
                                dwTrackIndex: LongInt):  BOOL ;stdcall;external 'HCNetSDK.dll'

{///文件查找与回放 }

function NET_DVR_FindFile(lUserID: LongInt; 
                          lChannel: LongInt; 
                          dwFileType: LongInt; 
                          var lpStartTime: NET_DVR_TIME; 
                          var lpStopTime: NET_DVR_TIME):  Longint ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_FindNextFile(lFindHandle: LongInt; 
                              var lpFindData: NET_DVR_FIND_DATA):  longint ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_FindClose(lFindHandle: LongInt):  BOOL ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_FindNextFile_V30(lFindHandle: LongInt; 
                                  var lpFindData: NET_DVR_FINDDATA_V30):  Longint ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_FindFile_V30(lUserID: LongInt; 
                              var pFindCond: NET_DVR_FILECOND):  Longint;stdcall;external 'HCNetSDK.dll'

function NET_DVR_FindClose_V30(lFindHandle: LongInt):  BOOL ;stdcall;external 'HCNetSDK.dll'
{///2007-04-16增加查询结果带卡号的文件查找 }

function NET_DVR_FindNextFile_Card(lFindHandle: LongInt; 
                                   var lpFindData: NET_DVR_FINDDATA_CARD):  Longint ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_FindFile_Card(lUserID: LongInt; 
                               lChannel: LongInt; 
                               dwFileType: LongInt; 
                               var lpStartTime: NET_DVR_TIME; 
                               var lpStopTime: NET_DVR_TIME):  Longint ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_LockFileByName(lUserID: LongInt; 
                                sLockFileName: PChar):  BOOL ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_UnlockFileByName(lUserID: LongInt; 
                                  sUnlockFileName: PChar):  BOOL ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_PlayBackByName(lUserID: LongInt; 
                                sPlayBackFileName: PChar; 
                                hWnd: HWND):  Longint ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_PlayBackByTime(lUserID: LongInt; 
                                lChannel: LongInt; 
                                var lpStartTime: NET_DVR_TIME; 
                                var lpStopTime: NET_DVR_TIME; 
                                hWnd: HWND):  Longint ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_PlayBackControl(lPlayHandle: LongInt; 
                                 dwControlCode: LongInt; 
                                 dwInValue: LongInt; 
                                 var LPOutValue: LongInt):  BOOL ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_StopPlayBack(lPlayHandle: LongInt):  BOOL ;stdcall;external 'HCNetSDK.dll'

Type TfPlayDataCallBack = procedure(lPlayHandle: Longint;
									dwDataType: LongInt; 
                                     pBuffer: LPByte; 
                                     dwBufSize: Longword; 
                                     dwUser: Longword);stdcall; 
function NET_DVR_SetPlayDataCallBack(lPlayHandle: LongInt; 
                                     fPlayDataCallBack:TfPlayDataCallBack;
                                     dwUser: Longword):  BOOL ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_PlayBackSaveData(lPlayHandle: LongInt; 
                                  sFileName: PChar):  BOOL ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_StopPlayBackSave(lPlayHandle: LongInt):  BOOL ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_GetPlayBackOsdTime(lPlayHandle: LongInt; 
                                    var lpOsdTime: NET_DVR_TIME):  BOOL ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_PlayBackCaptureFile(lPlayHandle: LongInt; 
                                     sFileName: PChar):  BOOL ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_GetFileByName(lUserID: LongInt; 
                               sDVRFileName: PChar; 
                               sSavedFileName: PChar):  Longint ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_GetFileByTime(lUserID: LongInt; 
                               lChannel: LongInt; 
                               var lpStartTime: NET_DVR_TIME; 
                               var lpStopTime: NET_DVR_TIME; 
                               sSavedFileName: PChar):  Longint ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_StopGetFile(lFileHandle: LongInt):  BOOL ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_GetDownloadPos(lFileHandle: LongInt):  integer ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_GetPlayBackPos(lPlayHandle: LongInt):  integer ;stdcall;external 'HCNetSDK.dll'

{///升级 }

function NET_DVR_Upgrade(lUserID: LongInt; 
                         sFileName: PChar):  Longint ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_GetUpgradeState(lUpgradeHandle: LongInt):  integer ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_GetUpgradeProgress(lUpgradeHandle: LongInt):  integer ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_CloseUpgradeHandle(lUpgradeHandle: LongInt):  BOOL ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_SetNetworkEnvironment(dwEnvironmentLevel: LongInt):  BOOL ;stdcall;external 'HCNetSDK.dll'
{///远程格式化硬盘 }

function NET_DVR_FormatDisk(lUserID: LongInt; 
                            lDiskNumber: LongInt):  Longint ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_GetFormatProgress(lFormatHandle: LongInt; 
                                   var pCurrentFormatDisk: LongInt; 
                                   var pCurrentDiskPos: LongInt; 
                                   var pFormatStatic: LongInt):  BOOL ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_CloseFormatHandle(lFormatHandle: LongInt):  BOOL ;stdcall;external 'HCNetSDK.dll'
{///报警 }

function NET_DVR_SetupAlarmChan(lUserID: LongInt):  LONGint ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_CloseAlarmChan(lAlarmHandle: LongInt):  BOOL ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_SetupAlarmChan_V30(lUserID: LongInt):  LONGint ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_SetupAlarmChan_V41(lUserID: LongInt;
                                    var lpSetupParam: NET_DVR_SETUPALARM_PARAM):  LONGint ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_CloseAlarmChan_V30(lAlarmHandle: LongInt):  BOOL ;stdcall;external 'HCNetSDK.dll'
{///语音对讲 }


type TfVoiceDataCallBack = procedure (lVoiceComHandle: longint;
							   pRecvDataBuffer: PChar; 
                               dwBufSize: LongInt; 
                               byAudioFlag: BYTE;
                               dwUser: Longword );stdcall;
function NET_DVR_StartVoiceCom(lUserID: LongInt; 
                               fVoiceDataCallBack:TfVoiceDataCallBack;
                               dwUser: Longword):  Longint ;stdcall;external 'HCNetSDK.dll'
                               
function NET_DVR_StartVoiceCom_V30(lUserID: LongInt; 
                                   dwVoiceChan: Longword; 
                                   bNeedCBNoEncData: Boolean; 
                                   fVoiceDataCallBack: TfVoiceDataCallBack; 
                                   pUser: Pointer):  Longint ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_SetVoiceComClientVolume(lVoiceComHandle: LongInt; 
                                         wVolume: Word):  BOOL ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_StopVoiceCom(lVoiceComHandle: LongInt):  BOOL ;stdcall;external 'HCNetSDK.dll'
{///语音转发 }

function NET_DVR_StartVoiceCom_MR(lUserID: LongInt; 
                                  fVoiceDataCallBack: TfVoiceDataCallBack;
                                  dwUser: LongInt):  Longint ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_StartVoiceCom_MR_V30(lUserID: LongInt; 
                                      dwVoiceChan: LongInt; 
                                      fVoiceDataCallBack: TfVoiceDataCallBack; 
                                      pUser: Pointer):  Longint ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_VoiceComSendData(lVoiceComHandle: LongInt; 
                                  pSendBuf: PChar; 
                                  dwBufSize: LongInt):  BOOL ;stdcall;external 'HCNetSDK.dll'

{///语音广播 }

function TNET_DVR_ClientAudioStart:  BOOL ;stdcall;external 'HCNetSDK.dll'

type TfVoiceDataCallBack_Multi = procedure (pRecvDataBuffer: PChar; dwBufSize: Longword; pUser: Pointer);stdcall;
function NET_DVR_ClientAudioStart_V30(
                                      fVoiceDataCallBack: TfVoiceDataCallBack_Multi;
                                      pUser: Pointer):  BOOL ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_ClientAudioStop:  BOOL ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_AddDVR(lUserID: LongInt):  BOOL ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_AddDVR_V30(lUserID: LongInt; 
                            dwVoiceChan: LongInt):  LONGint ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_DelDVR(lUserID: LongInt):  BOOL ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_DelDVR_V30(lVoiceHandle: LongInt):  BOOL ;stdcall;external 'HCNetSDK.dll'
{///////////////////////////////////////////////////////////// }
{///透明通道设置 }

type TfSerialDataCallBack= procedure(lSerialHandle: Longint;
                             pRecvDataBuffer: PChar; 
                             dwBufSize: Longword; 
                             dwUser: Longint );stdcall;
function NET_DVR_SerialStart(lUserID: LongInt; 
                             lSerialPort: LongInt; 
                             fSerialDataCallBack: TfSerialDataCallBack;
                             dwUser: Longword):  Longint ;stdcall;external 'HCNetSDK.dll'
{///485作为透明通道时，需要指明通道号，因为不同通道号485的设置可以不同(比如波特率) }

function NET_DVR_SerialSend(lSerialHandle: LongInt; 
                            lChannel: LongInt; 
                            pSendBuf: PChar; 
                            dwBufSize: LongInt):  BOOL ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_SerialStop(lSerialHandle: LongInt):  BOOL ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_SendTo232Port(lUserID: LongInt; 
                               pSendBuf: PChar; 
                               dwBufSize: LongInt):  BOOL ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_SendToSerialPort(lUserID: LongInt; 
                                  dwSerialPort: LongInt; 
                                  dwSerialIndex: LongInt; 
                                  pSendBuf: PChar; 
                                  dwBufSize: LongInt):  BOOL ;stdcall;external 'HCNetSDK.dll'

{///解码 nBitrate = 16000 }

function NET_DVR_InitG722Decoder(nBitrate: integer): Pointer ;stdcall;external 'HCNetSDK.dll'

procedure NET_DVR_ReleaseG722Decoder(pDecHandle: Pointer) ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_DecodeG722Frame(pDecHandle: Pointer; 
                                 var pInBuffer: Byte; 
                                 var pOutBuffer: Byte):  BOOL ;stdcall;external 'HCNetSDK.dll'
{///编码 }

function NET_DVR_InitG722Encoder(): Pointer ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_EncodeG722Frame(pEncodeHandle: Pointer; 
                                 var pInBuffer: Byte; 
                                 var pOutBuffer: Byte):  BOOL ;stdcall;external 'HCNetSDK.dll'

procedure NET_DVR_ReleaseG722Encoder(pEncodeHandle: Pointer) ;stdcall;external 'HCNetSDK.dll'

{///远程控制本地显示 }

function NET_DVR_ClickKey(lUserID: LongInt; 
                          lKeyIndex: LongInt):  BOOL ;stdcall;external 'HCNetSDK.dll'
{///远程控制设备端手动录像 }

function NET_DVR_StartDVRRecord(lUserID: LongInt; 
                                lChannel: LongInt; 
                                lRecordType: LongInt):  BOOL ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_StopDVRRecord(lUserID: LongInt; 
                               lChannel: LongInt):  BOOL ;stdcall;external 'HCNetSDK.dll'
{///解码卡 }

function NET_DVR_InitDevice_Card(var pDeviceTotalChan: LongInt):  BOOL ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_ReleaseDevice_Card:  BOOL ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_InitDDraw_Card(hParent: HWND; 
                                colorKey: TColorRef):  BOOL ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_ReleaseDDraw_Card:  BOOL ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_RealPlay_Card(lUserID: LongInt; 
                               var lpCardInfo: NET_DVR_CARDINFO; 
                               lChannelNum: LongInt):  LONGint ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_ResetPara_Card(lRealHandle: LongInt; 
                                var lpDisplayPara: NET_DVR_DISPLAY_PARA):  BOOL ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_RefreshSurface_Card:  BOOL ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_ClearSurface_Card:  BOOL ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_RestoreSurface_Card:  BOOL ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_OpenSound_Card(lRealHandle: LongInt):  BOOL ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_CloseSound_Card(lRealHandle: LongInt):  BOOL ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_SetVolume_Card(lRealHandle: LongInt; 
                                wVolume: Word):  BOOL ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_AudioPreview_Card(lRealHandle: LongInt; 
                                   bEnable: Bool):  BOOL ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_GetCardLastError_Card:  LONGint ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_GetChanHandle_Card(lRealHandle: LongInt):  HWND ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_CapturePicture_Card(lRealHandle: LongInt; 
                                     sPicFileName: PChar):  BOOL ;stdcall;external 'HCNetSDK.dll'
{///获取解码卡序列号此接口无效，改用GetBoardDetail接口获得(2005-12-08支持) }

function NET_DVR_GetSerialNum_Card(lChannelNum: LongInt; 
                                   var pDeviceSerialNo: LongInt):  BOOL ;stdcall;external 'HCNetSDK.dll'
{///日志 }

function NET_DVR_FindDVRLog(lUserID: LongInt; 
                            lSelectMode: LongInt; 
                            dwMajorType: LongInt; 
                            dwMinorType: LongInt; 
                            var lpStartTime: NET_DVR_TIME; 
                            var lpStopTime: NET_DVR_TIME):  LONGint ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_FindNextLog(lLogHandle: LongInt; 
                             var lpLogData: NET_DVR_LOG):  LONGint ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_FindLogClose(lLogHandle: LongInt):  BOOL ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_FindDVRLog_V30(lUserID: LongInt; 
                                lSelectMode: LongInt; 
                                dwMajorType: LongInt; 
                                dwMinorType: LongInt; 
                                var lpStartTime: NET_DVR_TIME; 
                                var lpStopTime: NET_DVR_TIME; 
                                BONLYSMART : Boolean):  LONGint ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_FindNextLog_V30(lLogHandle: LongInt; 
                                 var lpLogData: NET_DVR_LOG_V30):  LONGint ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_FindLogClose_V30(lLogHandle: LongInt):  BOOL ;stdcall;external 'HCNetSDK.dll'
{///截止2004年8月5日,共113个接口 }
{///ATM DVR }

function NET_DVR_FindFileByCard(lUserID: LongInt; 
                                lChannel: LongInt; 
                                dwFileType: LongInt; 
                                nFindType: Integer; 
                                var sCardNumber: BYTE; 
                                var lpStartTime: NET_DVR_TIME; 
                                var lpStopTime: NET_DVR_TIME):  LONGint ;stdcall;external 'HCNetSDK.dll'
{///截止2004年10月5日,共116个接口 }

{///编码 }

//function NET_DVR_InitG722Encoder(): Pointer;stdcall;external 'HCNetSDK.dll'

{function NET_DVR_EncodeG722Frame(pEncodeHandle: Pointer;
                                 var pInBuffer: Byte; 
                                 var pOutBuffer: Byte):  BOOL ;stdcall;external 'HCNetSDK.dll'}

//procedure NET_DVR_ReleaseG722Encoder(pEncodeHandle: Pointer) ;stdcall;external 'HCNetSDK.dll'
{///2005-09-15 }

function NET_DVR_CaptureJPEGPicture(lUserID: LongInt; 
                                    lChannel: LongInt; 
                                    var lpJpegPara: NET_DVR_JPEGPARA; 
                                    sPicFileName: PChar):  BOOL ;stdcall;external 'HCNetSDK.dll'
{///JPEG抓图到内存 }

function NET_DVR_CaptureJPEGPicture_NEW(lUserID: LongInt; 
                                        lChannel: LongInt; 
                                        var lpJpegPara: NET_DVR_JPEGPARA; 
                                        sJpegPicBuffer: PChar; 
                                        dwPicSize: LongInt; 
                                        var lpSizeReturned: LongInt):  BOOL ;stdcall;external 'HCNetSDK.dll'


{///2006-02-16 }

function NET_DVR_GetRealPlayerIndex(lRealHandle: LongInt):  integer ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_GetPlayBackPlayerIndex(lPlayHandle: LongInt):  integer ;stdcall;external 'HCNetSDK.dll'

{///2006-08-28 704-640 缩放配置 }

function NET_DVR_SetScaleCFG(lUserID: LongInt; 
                             dwScale: LongInt):  BOOL ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_GetScaleCFG(lUserID: LongInt; 
                             var lpOutScale: LongInt):  BOOL ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_SetScaleCFG_V30(lUserID: LongInt; 
                                 var pScalecfg: NET_DVR_SCALECFG):  BOOL ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_GetScaleCFG_V30(lUserID: LongInt; 
                                 var pScalecfg: NET_DVR_SCALECFG):  BOOL ;stdcall;external 'HCNetSDK.dll'
{///2006-08-28 ATM机端口设置 }

function NET_DVR_SetATMPortCFG(lUserID: LongInt; 
                               wATMPort: Word):  BOOL ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_GetATMPortCFG(lUserID: LongInt; 
                               var LPOutATMPort: Word):  BOOL ;stdcall;external 'HCNetSDK.dll'

{///2006-11-10 支持显卡辅助输出 }

function NET_DVR_InitDDrawDevice:  BOOL ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_ReleaseDDrawDevice:  BOOL ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_GetDDrawDeviceTotalNums:  LONGint ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_SetDDrawDevice(lPlayPort: LongInt; 
                                nDeviceNum: LongInt):  BOOL ;stdcall;external 'HCNetSDK.dll'


function NET_DVR_PTZSelZoomIn(lRealHandle: LongInt; 
                              var pStruPointFrame: NET_DVR_POINT_FRAME):  BOOL ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_PTZSelZoomIn_EX(lUserID: LongInt; 
                                 lChannel: LongInt; 
                                 var pStruPointFrame: NET_DVR_POINT_FRAME):  BOOL ;stdcall;external 'HCNetSDK.dll'



{///解码设备DS-6001D/DS-6001F }

function NET_DVR_StartDecode(lUserID: LongInt; 
                             lChannel: LongInt; 
                             var lpDecoderinfo: NET_DVR_DECODERINFO):  BOOL ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_StopDecode(lUserID: LongInt; 
                            lChannel: LongInt):  BOOL ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_GetDecoderState(lUserID: LongInt; 
                                 lChannel: LongInt; 
                                 var lpDecoderState: NET_DVR_DECODERSTATE):  BOOL ;stdcall;external 'HCNetSDK.dll'
{///2005-08-01 }

function NET_DVR_SetDecInfo(lUserID: LongInt; 
                            lChannel: LongInt; 
                            var lpDecoderinfo: NET_DVR_DECCFG):  BOOL ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_GetDecInfo(lUserID: LongInt; 
                            lChannel: LongInt; 
                            var lpDecoderinfo: NET_DVR_DECCFG):  BOOL ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_SetDecTransPort(lUserID: LongInt; 
                                 var lpTransPort: NET_DVR_PORTCFG):  BOOL ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_GetDecTransPort(lUserID: LongInt; 
                                 var lpTransPort: NET_DVR_PORTCFG):  BOOL ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_DecPlayBackCtrl(lUserID: LongInt; 
                                 lChannel: LongInt; 
                                 dwControlCode: LongInt; 
                                 dwInValue: LongInt; 
                                 var LPOutValue: LongInt; 
                                 var lpRemoteFileInfo: NET_DVR_PLAYREMOTEFILE):  BOOL ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_StartDecSpecialCon(lUserID: LongInt; 
                                    lChannel: LongInt; 
                                    var lpDecChanInfo: NET_DVR_DECCHANINFO):  BOOL ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_StopDecSpecialCon(lUserID: LongInt; 
                                   lChannel: LongInt; 
                                   var lpDecChanInfo: NET_DVR_DECCHANINFO):  BOOL ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_DecCtrlDec(lUserID: LongInt; 
                            lChannel: LongInt; 
                            dwControlCode: LongInt):  BOOL ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_DecCtrlScreen(lUserID: LongInt; 
                               lChannel: LongInt; 
                               dwControl: LongInt):  BOOL ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_GetDecCurLinkStatus(lUserID: LongInt; 
                                     lChannel: LongInt; 
                                     var lpDecStatus: NET_DVR_DECSTATUS):  BOOL ;stdcall;external 'HCNetSDK.dll'

{///多路解码器 }
{///2007-11-30 V211支持以下接口 //11 }

function NET_DVR_MatrixStartDynamic(lUserID: LongInt; 
                                    dwDecChanNum: LongInt; 
                                    var lpDynamicInfo: NET_DVR_MATRIX_DYNAMIC_DEC):  BOOL ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_MatrixStopDynamic(lUserID: LongInt; 
                                   dwDecChanNum: LongInt):  BOOL ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_MatrixGetDecChanInfo(lUserID: LongInt; 
                                      dwDecChanNum: LongInt; 
                                      var lpInter: NET_DVR_MATRIX_DEC_CHAN_INFO):  BOOL ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_MatrixSetLoopDecChanInfo(lUserID: LongInt; 
                                          dwDecChanNum: LongInt; 
                                          var lpInter: NET_DVR_MATRIX_LOOP_DECINFO):  BOOL ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_MatrixGetLoopDecChanInfo(lUserID: LongInt; 
                                          dwDecChanNum: LongInt; 
                                          var lpInter: NET_DVR_MATRIX_LOOP_DECINFO):  BOOL ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_MatrixSetLoopDecChanEnable(lUserID: LongInt; 
                                            dwDecChanNum: LongInt; 
                                            dwEnable: LongInt):  BOOL ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_MatrixGetLoopDecChanEnable(lUserID: LongInt; 
                                            dwDecChanNum: LongInt; 
                                            var lpdwEnable: LongInt):  BOOL ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_MatrixGetLoopDecEnable(lUserID: LongInt; 
                                        var lpdwEnable: LongInt):  BOOL ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_MatrixSetDecChanEnable(lUserID: LongInt; 
                                        dwDecChanNum: LongInt; 
                                        dwEnable: LongInt):  BOOL ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_MatrixGetDecChanEnable(lUserID: LongInt; 
                                        dwDecChanNum: LongInt; 
                                        var lpdwEnable: LongInt):  BOOL ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_MatrixGetDecChanStatus(lUserID: LongInt; 
                                        dwDecChanNum: LongInt; 
                                        var lpInter: NET_DVR_MATRIX_DEC_CHAN_STATUS):  BOOL ;stdcall;external 'HCNetSDK.dll'
{///2007-12-22 增加支持接口 //18 }

function NET_DVR_MatrixSetTranInfo(lUserID: LongInt; 
                                   var lpTranInfo: NET_DVR_MATRIX_TRAN_CHAN_CONFIG):  BOOL ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_MatrixGetTranInfo(lUserID: LongInt; 
                                   var lpTranInfo: NET_DVR_MATRIX_TRAN_CHAN_CONFIG):  BOOL ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_MatrixSetRemotePlay(lUserID: LongInt; 
                                     dwDecChanNum: LongInt; 
                                     var lpInter: NET_DVR_MATRIX_DEC_REMOTE_PLAY):  BOOL ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_MatrixSetRemotePlayControl(lUserID: LongInt; 
                                            dwDecChanNum: LongInt; 
                                            dwControlCode: LongInt; 
                                            dwInValue: LongInt; 
                                            var LPOutValue: LongInt):  BOOL ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_MatrixGetRemotePlayStatus(lUserID: LongInt; 
                                           dwDecChanNum: LongInt; 
                                           var lpOuter: NET_DVR_MATRIX_DEC_REMOTE_PLAY_STATUS):  BOOL ;stdcall;external 'HCNetSDK.dll'
{///end }

function NET_DVR_RefreshPlay(lPlayHandle: LongInt):  BOOL ;stdcall;external 'HCNetSDK.dll'
{///恢复默认值 }

function NET_DVR_RestoreConfig(lUserID: LongInt):  BOOL ;stdcall;external 'HCNetSDK.dll'
{///保存参数 }

function NET_DVR_SaveConfig(lUserID: LongInt):  BOOL ;stdcall;external 'HCNetSDK.dll'
{///重启 }

function NET_DVR_RebootDVR(lUserID: LongInt):  BOOL ;stdcall;external 'HCNetSDK.dll'
{///关闭DVR }

function NET_DVR_ShutDownDVR(lUserID: LongInt):  BOOL ;stdcall;external 'HCNetSDK.dll'



{///参数配置 begin }

function NET_DVR_GetDVRConfig(lUserID: LongInt;
                              dwCommand: LongInt; 
                              lChannel: LongInt;
                              lpOutBuffer: Pointer;
                              dwOutBufferSize: LongInt; 
                              lpBytesReturned: pLongInt):  BOOL ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_GetDeviceConfig(lUserID: LongInt;
                              dwCommand: LongInt;
                              dwCount: LongInt;
                              lpInBuffer: Pointer;
                              dwInBufferSize: LongInt;
                              lpStatusList: Pointer;
                              lpOutBuffer: Pointer;
                              dwOutBufferSize: LongInt):  BOOL ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_SetDVRConfig(lUserID: LongInt; 
                              dwCommand: LongInt; 
                              lChannel: LongInt; 
                              lpInBuffer: Pointer;
                              dwInBufferSize: LongInt):  BOOL ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_GetDVRWorkState_V30(lUserID: LongInt; 
                                     var lpWorkState: NET_DVR_WORKSTATE_V30):  BOOL ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_GetDVRWorkState(lUserID: LongInt; 
                                 var lpWorkState: NET_DVR_WORKSTATE):  BOOL ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_SetVideoEffect(lUserID: LongInt; 
                                lChannel: LongInt; 
                                dwBrightValue: LongInt; 
                                dwContrastValue: LongInt; 
                                dwSaturationValue: LongInt; 
                                dwHueValue: LongInt):  BOOL ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_GetVideoEffect(lUserID: LongInt; 
                                lChannel: LongInt; 
                                var pBrightValue: LongInt; 
                                var pContrastValue: LongInt; 
                                var pSaturationValue: LongInt; 
                                var pHueValue: LongInt):  BOOL ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_ClientGetframeformat(lUserID: LongInt; 
                                      var lpFrameFormat: NET_DVR_FRAMEFORMAT):  BOOL ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_ClientSetframeformat(lUserID: LongInt; 
                                      var lpFrameFormat: NET_DVR_FRAMEFORMAT):  BOOL ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_ClientGetframeformat_V30(lUserID: LongInt; 
                                          var lpFrameFormat: NET_DVR_FRAMEFORMAT_V30):  BOOL ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_ClientSetframeformat_V30(lUserID: LongInt; 
                                          var lpFrameFormat: NET_DVR_FRAMEFORMAT_V30):  BOOL ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_GetAlarmOut_V30(lUserID: LongInt; 
                                 var lpAlarmOutState: NET_DVR_ALARMOUTSTATUS_V30):  BOOL ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_GetAlarmOut(lUserID: LongInt; 
                             var lpAlarmOutState: NET_DVR_ALARMOUTSTATUS):  BOOL ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_SetAlarmOut(lUserID: LongInt; 
                             lAlarmOutPort: LongInt; 
                             lAlarmOutStatic: LongInt):  BOOL ;stdcall;external 'HCNetSDK.dll'

{///视频参数调节 }

function NET_DVR_ClientSetVideoEffect(lRealHandle: LongInt; 
                                      dwBrightValue: LongInt; 
                                      dwContrastValue: LongInt; 
                                      dwSaturationValue: LongInt; 
                                      dwHueValue: LongInt):  BOOL ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_ClientGetVideoEffect(lRealHandle: LongInt; 
                                      var pBrightValue: LongInt; 
                                      var pContrastValue: LongInt; 
                                      var pSaturationValue: LongInt; 
                                      var pHueValue: LongInt):  BOOL ;stdcall;external 'HCNetSDK.dll'

{///配置文件 }

function NET_DVR_GetConfigFile(lUserID: LongInt; 
                               sFileName: PChar):  BOOL ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_SetConfigFile(lUserID: LongInt; 
                               sFileName: PChar):  BOOL ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_GetConfigFile_V30(lUserID: LongInt; 
                                   sOutBuffer: PChar; 
                                   dwOutSize: LongInt; 
                                   var pReturnSize: LongInt):  BOOL ;stdcall;external 'HCNetSDK.dll'


function NET_DVR_GetConfigFile_EX(lUserID: LongInt; 
                                  sOutBuffer: PChar; 
                                  dwOutSize: LongInt):  BOOL ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_SetConfigFile_EX(lUserID: LongInt; 
                                  sInBuffer: PChar; 
                                  dwInSize: LongInt):  BOOL ;stdcall;external 'HCNetSDK.dll'

{///启用日志文件写入接口 }

function NET_DVR_SetLogToFile(BLOGENABLE : LongInt; 
                              STRLOGDIR: PChar; 
                              BAUTODEL: Boolean):  BOOL ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_GetSDKState(var pSDKState: NET_DVR_SDKSTATE):  BOOL ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_GetSDKAbility(var pSDKAbl: NET_DVR_SDKABL):  BOOL ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_GetPTZProtocol(lUserID: LongInt; 
                                var pPtzcfg: NET_DVR_PTZCFG):  BOOL ;stdcall;external 'HCNetSDK.dll'
{///前面板锁定 }

function NET_DVR_LockPanel(lUserID: LongInt):  BOOL ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_UnLockPanel(lUserID: LongInt):  BOOL ;stdcall;external 'HCNetSDK.dll'


function NET_DVR_SetRtspConfig(lUserID: LongInt; 
                               dwCommand: LongInt; 
                               var lpInBuffer: NET_DVR_RTSPCFG; 
                               dwInBufferSize: LongInt):  BOOL ;stdcall;external 'HCNetSDK.dll'

function NET_DVR_GetRtspConfig(lUserID: LongInt; 
                               dwCommand: LongInt; 
                               var lpOutBuffer: NET_DVR_RTSPCFG; 
                               dwOutBufferSize: LongInt):  BOOL ;stdcall;external 'HCNetSDK.dll'



{$ENDIF //}

implementation


end.
